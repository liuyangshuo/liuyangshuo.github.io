<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘养硕的博客</title>
  
  <subtitle>记录工作和学习的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liuyangshuo.com/"/>
  <updated>2018-12-14T01:58:28.254Z</updated>
  <id>http://liuyangshuo.com/</id>
  
  <author>
    <name>刘养硕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Emscripten IndexedDB</title>
    <link href="http://liuyangshuo.com/2018/12/12/IndexedDB/"/>
    <id>http://liuyangshuo.com/2018/12/12/IndexedDB/</id>
    <published>2018-12-12T02:00:00.000Z</published>
    <updated>2018-12-14T01:58:28.254Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文件介绍两种操作IndexedDB的方式，一种是通过Emscripten文件系统层提供的IndexedDb方法；另一种是通过fetch来存储网络服务器中的文件或内存文件。第一种方式适用于存储小型数据，第二种方式适用于存储大型文件。</p><h2 id="Emscripten异步IndexedDB-API"><a href="#Emscripten异步IndexedDB-API" class="headerlink" title="Emscripten异步IndexedDB API"></a>Emscripten异步IndexedDB API</h2><p>IndexedDB是一个允许您持久存储数据的浏览器API，也就是说，您可以将数据保存在那里，然后在用户重新访问网页时加载数据。IDBFS通过Emscripten文件系统层提供了一种使用IndexedDB的方法。emscripten_idb_*此处列出的方法提供了一个直接指向IndexedDB的替代API，从而避免了文件系统层的开销。<br><a id="more"></a><br>下面通过一个简单示例来演示数据的基本操作：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;emscripten.h&gt;</span><br><span class="line"></span><br><span class="line">#define DB &quot;THE_DB&quot;</span><br><span class="line">#define STAGE 0</span><br><span class="line"></span><br><span class="line">int expected;</span><br><span class="line">int result;</span><br><span class="line"></span><br><span class="line">void ok(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;arg = %d\n&quot;, (int)arg;</span><br><span class="line">    printf(&quot;expected = %d\n&quot;, expected);</span><br><span class="line">    assert(expected == (int)arg);</span><br><span class="line">    //REPORT_RESULT(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onerror(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    assert(expected == (int)arg);</span><br><span class="line">    //REPORT_RESULT(999);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onload(void* arg, void* ptr, int num)</span><br><span class="line">&#123;</span><br><span class="line">    assert(expected == (int)arg);</span><br><span class="line">    printf(&quot;loaded %s\n&quot;, ptr);</span><br><span class="line">    assert(num == strlen(SECRET)+1);</span><br><span class="line">    assert(strcmp(ptr, SECRET) == 0);</span><br><span class="line">    //REPORT_RESULT(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onbadload(void* arg, void* ptr, int num)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;load failed, surprising\n&quot;);</span><br><span class="line">    //REPORT_RESULT(999);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void oncheck(void* arg, int exists)</span><br><span class="line">&#123;</span><br><span class="line">    assert(expected == (int)arg);</span><br><span class="line">    printf(&quot;exists? %d\n&quot;, exists);</span><br><span class="line">    assert(exists);</span><br><span class="line">    //REPORT_RESULT(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onchecknope(void* arg, int exists)</span><br><span class="line">&#123;</span><br><span class="line">    assert(expeted == (int)arg);</span><br><span class="line">    printf(&quot;exists (hopefully not)? %d\n&quot;, exists);</span><br><span class="line">    assert(!exists);</span><br><span class="line">    //REPORT_RESULT(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line">  result = STAGE;</span><br><span class="line">#if STAGE == 0</span><br><span class="line">  expected = 12;</span><br><span class="line">  emscripten_idb_async_store(DB, &quot;the_secret&quot;, SECRET, strlen(SECRET)+1, (void*)expected, ok, onerror);</span><br><span class="line">  printf(&quot;storing %s\n&quot;, SECRET);</span><br><span class="line">#elif STAGE == 1</span><br><span class="line">  expected = 12;</span><br><span class="line">  emscripten_idb_async_load(DB, &quot;the_secret&quot;, (void*)expected, onload, onerror);</span><br><span class="line">//  printf(&quot;onload %d\n&quot;, (int)onload);</span><br><span class="line">#elif STAGE == 2</span><br><span class="line">  expected = 44;</span><br><span class="line">  emscripten_idb_async_delete(DB, &quot;the_secret&quot;, (void*)expected, ok, onerror);</span><br><span class="line">  printf(&quot;deleting the_secret\n&quot;);</span><br><span class="line">#elif STAGE == 3</span><br><span class="line">  expected = 55;</span><br><span class="line">  emscripten_idb_async_load(DB, &quot;the_secret&quot;, (void*)expected, onbadload, ok);</span><br><span class="line">  printf(&quot;loading, should fail as we deleted\n&quot;);</span><br><span class="line">#elif STAGE == 4</span><br><span class="line">  expected = 66;</span><br><span class="line">  emscripten_idb_async_exists(DB, &quot;the_secret&quot;, (void*)expected, oncheck, onerror);</span><br><span class="line">#elif STAGE == 5</span><br><span class="line">  expected = 77;</span><br><span class="line">  emscripten_idb_async_exists(DB, &quot;the_secret&quot;, (void*)expected, onchecknope, onerror);</span><br><span class="line">#else</span><br><span class="line">  assert(0);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void never() &#123;</span><br><span class="line">  EM_ASM(&#123; alert(&apos;this should never be reached! runtime must not be shut down!&apos;) &#125;);</span><br><span class="line">  assert(0);</span><br><span class="line">  while (1) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  //atexit(never);</span><br><span class="line">  test();</span><br><span class="line">  emscripten_exit_with_live_runtime();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法说明：</p><blockquote><p>void emscritpen_idb_async_load(const cahr <em>db_name, const char </em>file_id, void* arg, em_async_wget_onload_func onload, em_arg_callback_func onerror)</p></blockquote><p>异步从本地IndexedDB存储加载数据。这允许持久数据，而不需要文件系统层的开销，当数据准备就绪时，onload函数会被调用，如果发生任何错误则onerror会被调用</p><p>参数：</p><ul><li>db_name：从哪个数据库加载数据</li><li>file_id:要加载的数据标识符</li><li>arg(void*):传递给毁掉的用户定义的数据，不受API本身的影响。这可以被回调用来标识相关的调用</li><li>onload(em_async_wget_onload_func):成功将URL加载到缓冲区是进行回调，回调方法参数：<ul><li>(void)*:等于arg(用户定义数据)</li><li>(void)*:指向带有数据的缓冲区指针</li><li>(int)：缓冲区大小，以字节为单位</li></ul></li><li>onerror(em_arg_callback_func):<ul><li>(void)*：等于arg(用户定义数据)</li></ul></li></ul><blockquote><p>void emscripten_idb_async_store(const char <em>db_name, const char </em>file_id, void<em> ptr, int num, void</em> arg, em_arg_callback_func onstore, em_arg_callback_func onerror)</p></blockquote><p>异步存储数据到本地IndexedDB。不需要文件系统层就可以将数据持久化。当数据存储存储时会调用onstore函数，如果发生错误就会调用onerror函数。</p><p>参数：</p><ul><li>ptr:指向存储数据的指针</li><li>num:存储的数据有多少字节</li><li>onstore(em_arg_callback_func):对数据缓冲区成功存储到URL的回调</li></ul><blockquote><p>void emscripten_idb_async_delete(const char <em>db_name, const char </em>file_id, void *arg, em_arg_callback_func ondelete, em_arg_callback_func onerror)</p></blockquote><p>从本地IndexedDB数据库异步删除数据。当数据被删除试调用ondelte函数，当发生错误是调用onerror函数。</p><p>参数：</p><ul><li>ondelete(em_arg_callback_func):成功删除的回调</li></ul><blockquote><p>void emscripten_idb_async_exists(const char <em>db_name, const char </em>file_id, void* arg, em_idb_exists_func oncheck, em_arg_callback_func onerror)</p></blockquote><p>异步检查本地IndexedDB数据库中是否存在特定ID的数据。当数据被选中是，则调用oncheck函数，如果发生错误就会调用onerror函数</p><p>参数：</p><ul><li>oncheck(em_idb_exists_func):成功检查的回调，回调函数参数：<ul><li>int:文件是否存在</li></ul></li></ul><blockquote><p>int emscripten_run_preload_plugins(const char* file, em_str_callback_func onload, em_str_callback_func onerror)</p></blockquote><p>异步地在文件上运行预加载插件。它工作在已经存在的文件数据上，并执行任何可用的作为预加载插件的所需的异步操作，例如解码图像以供在IMG_Load中使用的音频解码Mix_LoadWAV。操作完成后会调用onload函数，如果发生错误则调用onerror函数</p><p>参数：</p><ul><li>onload(em_str_callback_func):对文件的成功处理进行回调,回调函数参数：<ul><li>(const char)*:处理的文件</li></ul></li><li>onerror(em_str_callback_func):调用失败，回调函数参数：<ul><li>(const char)*:操作失败的文件</li></ul></li></ul><h2 id="通过Fetch-API操作IndexedDB"><a href="#通过Fetch-API操作IndexedDB" class="headerlink" title="通过Fetch API操作IndexedDB"></a>通过Fetch API操作IndexedDB</h2><h3 id="从网络文件持久化数据"><a href="#从网络文件持久化数据" class="headerlink" title="从网络文件持久化数据"></a>从网络文件持久化数据</h3><p>Emscripten FETCH API允许本机代码通过XHR(HTTPGET、PUT、POST)从远程服务器传输文件，并在浏览器的IndexedDB存储中本地宝存已下载的文件，以便在随后的也米恩访问是能够在本地重新访问这些文件。</p><blockquote><p>为了使用FETCH API，需要使用-s FETCH=1。</p></blockquote><p>下面的应用程序异步地将文件从Web服务器下载到应用程序堆中的内存和IndexedDB中。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;emscripten/fetch.h&gt;</span><br><span class="line"></span><br><span class="line">void downloadSucceeded(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;Finished downloading %llu bytes from URL %s.\n&quot;, fetch-&gt;numBytes, fetch-&gt;url);</span><br><span class="line">  // The data is now available at fetch-&gt;data[0] through fetch-&gt;data[fetch-&gt;numBytes-1];</span><br><span class="line">  emscripten_fetch_close(fetch); // Free data associated with the fetch.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void downloadFailed(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;Downloading %s failed, HTTP failure status code: %d.\n&quot;, fetch-&gt;url, fetch-&gt;status);</span><br><span class="line">  emscripten_fetch_close(fetch); // Also free data on failure.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  emscripten_fetch_attr_t attr;</span><br><span class="line">  emscripten_fetch_attr_init(&amp;attr);</span><br><span class="line">  strcpy(attr.requestMethod, &quot;GET&quot;);</span><br><span class="line">  attr.attributes = EMSCRIPTEN_FETCH_LOAD_TO_MEMORY | EMSCRIPTEN_FETCH_PERSIST_FILE;</span><br><span class="line">  attr.onsuccess = downloadSucceeded;</span><br><span class="line">  attr.onerror = downloadFailed;</span><br><span class="line">  emscripten_fetch(&amp;attr, &quot;myfile.dat&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果为调用Emscripten_FETCH指定了相对路径名，如上面的示例所示，则相对于当前页面的href(URL)执行XHR。传递完全限定的绝对URL允许跨域下载文件，但是这些文件必须符合http访问控制(CORS)规则.</p><p>默认情况下，FETCH API异步运行，这意味着Emscripten_FETCH()函数调用将立即返回，并且操作将继续发生在后台。操作完成后，将调用“成功”或“失败”回调。</p><p>FETCH API发出的XHR请求受制于通常的浏览器缓存行为。这些缓存是暂时性的(临时的)，因此无法保证数据将在给定的一段时间内持续在缓存中。此外，如果文件有点大(多兆字节)，浏览器通常根本不缓存下载。<br>为了支持保存下载文件的更显式控制，FETCH API与浏览器的IndexedDBAPI交互，后者可以加载和存储在以后访问页面时可用的大型数据文件。<br>如果应用程序希望下载一个文件以进行本地访问，但不需要立即使用该文件，例如，当预先为以后的访问预先加载数据时，最好完全避免使用Emscripten_FETCH_LOAD_TO_Memory标志，而只传递Emscripten_FETCH_REVERT_FILE_FILE标志。这将导致FETCH直接将文件下载到IndexedDB，从而避免在下载完成后暂时将文件填充到内存中。在这种情况下，onSuccess()处理程序将只报告下载的文件大小，而不会将数据字节包含到文件中。</p><h3 id="从内存中持久化数据"><a href="#从内存中持久化数据" class="headerlink" title="从内存中持久化数据"></a>从内存中持久化数据</h3><p>有时，从应用程序内存到IndexedDB(不需要执行任何XHR)的字节范围很有用。通过将特殊的HTTP动作动词“EM_IDB_STORE”传递给Emscripten提取操作，这在Emscripten FETCH API中是可能的。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void success(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;IDB store succeeded.\n&quot;);</span><br><span class="line">  emscripten_fetch_close(fetch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void failure(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;IDB store failed.\n&quot;);</span><br><span class="line">  emscripten_fetch_close(fetch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void persistFileToIndexedDB(const char *outputFilename, uint8_t *data, size_t numBytes) &#123;</span><br><span class="line">  emscripten_fetch_attr_t attr;</span><br><span class="line">  emscripten_fetch_attr_init(&amp;attr);</span><br><span class="line">  strcpy(attr.requestMethod, &quot;EM_IDB_STORE&quot;);</span><br><span class="line">  attr.attributes = EMSCRIPTEN_FETCH_REPLACE | EMSCRIPTEN_FETCH_PERSIST_FILE;</span><br><span class="line">  attr.requestData = (char *)data;</span><br><span class="line">  attr.requestDataSize = numBytes;</span><br><span class="line">  attr.onsuccess = success;</span><br><span class="line">  attr.onerror = failure;</span><br><span class="line">  emscripten_fetch(&amp;attr, outputFilename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  // Create data</span><br><span class="line">  uint8_t *data = (uint8_t*)malloc(10240);</span><br><span class="line">  srand(time(NULL));</span><br><span class="line">  for(int i = 0; i &lt; 10240; ++i) data[i] = (uint8_t)rand();</span><br><span class="line"></span><br><span class="line">  persistFileToIndexedDB(&quot;outputfile.dat&quot;, data, 10240);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从IndexedDB删除文件"><a href="#从IndexedDB删除文件" class="headerlink" title="从IndexedDB删除文件"></a>从IndexedDB删除文件</h3><p>可以使用HTTP动作动词“EM_IDB_DELETE”从IndexedDB清除文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void success(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;Deleting file from IDB succeeded.\n&quot;);</span><br><span class="line">  emscripten_fetch_close(fetch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void failure(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;Deleting file from IDB failed.\n&quot;);</span><br><span class="line">  emscripten_fetch_close(fetch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  emscripten_fetch_attr_init(&amp;attr);</span><br><span class="line">  strcpy(attr.requestMethod, &quot;EM_IDB_DELETE&quot;);</span><br><span class="line">  emscripten_fetch(&amp;attr, &quot;filename_to_delete.dat&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文件介绍两种操作IndexedDB的方式，一种是通过Emscripten文件系统层提供的IndexedDb方法；另一种是通过fetch来存储网络服务器中的文件或内存文件。第一种方式适用于存储小型数据，第二种方式适用于存储大型文件。&lt;/p&gt;
&lt;h2 id=&quot;Emscripten异步IndexedDB-API&quot;&gt;&lt;a href=&quot;#Emscripten异步IndexedDB-API&quot; class=&quot;headerlink&quot; title=&quot;Emscripten异步IndexedDB API&quot;&gt;&lt;/a&gt;Emscripten异步IndexedDB API&lt;/h2&gt;&lt;p&gt;IndexedDB是一个允许您持久存储数据的浏览器API，也就是说，您可以将数据保存在那里，然后在用户重新访问网页时加载数据。IDBFS通过Emscripten文件系统层提供了一种使用IndexedDB的方法。emscripten_idb_*此处列出的方法提供了一个直接指向IndexedDB的替代API，从而避免了文件系统层的开销。&lt;br&gt;
    
    </summary>
    
      <category term="WebAssembly" scheme="http://liuyangshuo.com/categories/WebAssembly/"/>
    
    
      <category term="WebAssembly" scheme="http://liuyangshuo.com/tags/WebAssembly/"/>
    
      <category term="Emscripten" scheme="http://liuyangshuo.com/tags/Emscripten/"/>
    
      <category term="IndexedDB" scheme="http://liuyangshuo.com/tags/IndexedDB/"/>
    
      <category term="Fetch" scheme="http://liuyangshuo.com/tags/Fetch/"/>
    
  </entry>
  
  <entry>
    <title>Emscripten Embind</title>
    <link href="http://liuyangshuo.com/2018/12/09/Embind/"/>
    <id>http://liuyangshuo.com/2018/12/09/Embind/</id>
    <published>2018-12-09T02:30:00.000Z</published>
    <updated>2018-12-12T04:00:11.342Z</updated>
    
    <content type="html"><![CDATA[<p>Embind用于将C++函数和类绑定到javascript,这样编译的代码就可以通过javascript来调用<br>本文介绍如何使用EMSCRIPTEN_BINDINGS()块来为函数、类、值类型、指针（包括原始指针和智能指针）、枚举和常量创建绑定，以及如何为可以在javascript中重写的抽象类创建绑定。还简要解释了如何管理传递给javascript的C++对象句柄的内存</p><hr><a id="more"></a><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p>下面以一个简单的例子开始</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//quick_example.cpp</span><br><span class="line">#include &lt;emscripten/bind.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace emscripten;</span><br><span class="line"></span><br><span class="line">float lerp(float a, float b, float t) &#123;</span><br><span class="line">    return (1 - t) * a + t * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(my_module) &#123;</span><br><span class="line">    function(&quot;lerp&quot;, &amp;lerp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对以上代码进行编译，编译需要加–bind参数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc --bind -o quick_example.js quick_example.cpp</span><br></pre></td></tr></table></figure></p><p>编译之后就可以在javascript代码中调用上边的注册函数</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Module = &#123;</span><br><span class="line">    onRuntimeInitialized: function() &#123;</span><br><span class="line">        console.log(&apos;lerp result: &apos; + Module.lerp(1, 2, 0.5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;quick_example.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="类和内存管理"><a href="#类和内存管理" class="headerlink" title="类和内存管理"></a>类和内存管理</h3><p>向javascript公开类需要一个更复杂的绑定语句：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    MyClass(int x, std::string y): x(x), y(y) &#123;&#125;</span><br><span class="line">    void incrementX() &#123;</span><br><span class="line">        ++x;</span><br><span class="line">    &#125;</span><br><span class="line">    int getX() const &#123; return x;&#125;</span><br><span class="line">    void setX(int x_) &#123; x = x_; &#125;</span><br><span class="line">    static std::string getStringFromInstance(const MyClass&amp; instance) &#123;</span><br><span class="line">        return instance.y;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">    std::stirng y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//Binding code</span><br><span class="line">EMSCRIPTEN_BINDINGS(my_class_example) &#123;</span><br><span class="line">    class_&lt;MyClass&gt;(&quot;MyClass&quot;)</span><br><span class="line">    .constructor&lt;int, std::string&gt;() //构造函数</span><br><span class="line">    .function(&quot;incrementX&quot;, &amp;MyClass::incrementX) //非静态函数</span><br><span class="line">    .property(&quot;x&quot;, &amp;MyClass::getX, &amp;MyClass:setX)</span><br><span class="line">    .class_function(&quot;getStringFromInstance&quot;, &amp;MyClass:getStringFromInstance) //静态函数</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在javascript中使用：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var instance = new Module.MyClass(10, &quot;hello&quot;);</span><br><span class="line">instance.incrementX();</span><br><span class="line">instance.x; // 11</span><br><span class="line">instance.x = 20 // 20</span><br><span class="line">Module.MyClass.getStringFromInstance(instance); // &quot;hello&quot;</span><br><span class="line">instance.delete();</span><br></pre></td></tr></table></figure><p>由于Emscripten无法自动调用C++对象的析构函数，所以javascript代码必须显示删除他接收到的任何C++对象句柄，否则Emscripten堆将无限期地增长</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>基本类型的手动内存管理非常麻烦，因此Embind提供对值类型的支持。Value arrays转换为javascript数组和value objects转换为javascript对象</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct Point2f &#123;</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct PersonRecord &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PersonRecord findPersonAtLocation(Point2f);</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(my_value_example) &#123;</span><br><span class="line">    value_array&lt;Point2f&gt;(&quot;Point2f&quot;)</span><br><span class="line">        .element(&amp;Point2f::x)</span><br><span class="line">        .element(&amp;Point2f::y)</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">    value_object&lt;PersonRecord&gt;(&quot;PersonRecord&quot;)</span><br><span class="line">        .field(&quot;name&quot;, &amp;PersonRecord::name)</span><br><span class="line">        .field(&quot;age&quot;, &amp;PersonRecord::age)</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">    function(&quot;findPersonAtLocation&quot;, &amp;findPersonAtLocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式javascript就无需考虑对象的生命周期</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person = Module.findPersonAtLocation([10.2, 156.5]);</span><br><span class="line">console.log(&apos;Found someone! Their name is &apos; + person.name + &apos;and they are&apos; + person.age + &apos; years old&apos;);</span><br></pre></td></tr></table></figure><h3 id="高级类概念"><a href="#高级类概念" class="headerlink" title="高级类概念"></a>高级类概念</h3><h4 id="原始指针"><a href="#原始指针" class="headerlink" title="原始指针"></a>原始指针</h4><p>因为原始指针的语义不明确，embind需要将使用allow_raw_pointers标记：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;&#125;;</span><br><span class="line">C* passThrough(C* ptr) &#123; return ptr; &#125;</span><br><span class="line">EMSCRIPTEN_BINDINGS(raw_pointers) &#123;</span><br><span class="line">    class&gt;&lt;C&gt;(&quot;C&quot;);</span><br><span class="line">    function(&quot;passThrough&quot;, &amp;passThrough, allow_raw_pointers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部构造函数"><a href="#外部构造函数" class="headerlink" title="外部构造函数"></a>外部构造函数</h4><p>这里有两种方法来指定类的构造函数<br>一种是零参数模板形式，使用模板中指定的参数调用自然构造函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    MyClass(int, float);</span><br><span class="line">    void someFunction();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(external_constructors) &#123;</span><br><span class="line">    class_&lt;MyClass&gt;(&quot;MyClass&quot;)</span><br><span class="line">        .constructor&lt;int, float&gt;()</span><br><span class="line">        .function(&quot;someFunction&quot;, &amp;MyClass::someFunction)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种形式是接受函数指针参数，并用于使用工厂函数构造自身的类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    virtual void someFunction() = 0；</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass* makeMyClass(int, float); //Factory function</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(external_constructors) &#123;</span><br><span class="line">    class_&lt;MyClass&gt;(&quot;MyClass&quot;)</span><br><span class="line">        .constructor(&amp;makeMyClass, allow_raw_pointers())</span><br><span class="line">        .function(&quot;someFunction&quot;, &amp;MyClass::someFunction)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面两种形式作为接口在JavaScript中使用时是相同的：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var instance = new MyClass(10, 15.5);</span><br><span class="line">// instance is backed by a raw pointer to a MyClass in the Emscripten heap</span><br></pre></td></tr></table></figure><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>如果要使用智能指针来管理对象的生存周期，Embind必须指出智能指针的类型。<br>例如，考虑通过一个指向类C的智能指针std::shared_ptr<c>的生存周期，最好的方式是使用smart_ptr_constructor()来注册智能指针类型：</c></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(better_smart_pointers) &#123;</span><br><span class="line">    class_&lt;C&gt;(&quot;C&quot;)</span><br><span class="line">        .smart_ptr_constructor(&quot;C&quot;, &amp;std::make_shared&lt;C&gt;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个类型的一个对象被构造（如，new Module.C() ),就会返回一个智能指针std::shared_ptr<c>.<br>另一只形式是在EMSCRIPTEN_BINDINGS()中使用smart_ptr().</c></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(smart_pointers) &#123;</span><br><span class="line">    class_&lt;C&gt;(&quot;C&quot;)</span><br><span class="line">        .constructor&lt;&gt;()</span><br><span class="line">        .smart_ptr&lt;std::shared_ptr&lt;C&gt;&gt;(&quot;C&quot;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该定义可以返回一个std::shared_ptr<c>。或者使用std::shared_ptr<c>作为参数，但是使用new Module.C()将会返回一个原始指针。</c></c></p><h5 id="唯一智能指针"><a href="#唯一智能指针" class="headerlink" title="唯一智能指针"></a>唯一智能指针</h5><p>同共享指针一样不过返回类型为std::unique_ptr。</p><h5 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h5><p>关于自定义智能指针模板，必须使用专门的smart_ptr_trait模板。</p><h4 id="JavaScript原型上的非成员函数"><a href="#JavaScript原型上的非成员函数" class="headerlink" title="JavaScript原型上的非成员函数"></a>JavaScript原型上的非成员函数</h4><p>JavaScript原型上的方法可以是非成员函数，主要实例句柄可以转换为非成员函数的第一个参数。典型的例子是当向JavaScript公开的函数与C++方法的行为不完全匹配时。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Array10 &#123;</span><br><span class="line">    int&amp; get(size_t index) &#123;</span><br><span class="line">        return data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    int data[10];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">val Array10_get(Array10&amp; arr, size_t index) &#123;</span><br><span class="line">    if (index &lt; 10) &#123;</span><br><span class="line">        return val(arr.get(index));</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">            return val::undefined();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(non_member_functions) &#123;</span><br><span class="line">    class_&lt;Array10&gt;(&quot;Array10&quot;)</span><br><span class="line">        .function(&quot;get&quot;, &amp;Array10_get)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在JavaScript中派生C-类"><a href="#在JavaScript中派生C-类" class="headerlink" title="在JavaScript中派生C++类"></a>在JavaScript中派生C++类</h4><p>如果C++类中有虚拟或抽象成员函数，则可以在JavaScript中重写他们。因为JavaScript没有C++虚函数表的信息，Embind需要一点胶水代码将C++虚函数调用转换为JavaScript调用。</p><h5 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h5><p>通过一个例子来说明，该方法必须通过JavaScript实现。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Interface &#123;</span><br><span class="line">    virtual void invoke(const std::string&amp; str) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct InterfaceWrapper : public wrapper&lt;Interface&gt; &#123;</span><br><span class="line">    EMSCRIPTEN_WRAPPER(InterfaceWrapper);</span><br><span class="line">    void invoke(const std::string&amp; str) &#123;</span><br><span class="line">        return call&lt;void&gt;(&quot;invoke&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(interface) &#123;</span><br><span class="line">    class_&lt;Interface&gt;(&quot;Interface&quot;)</span><br><span class="line">        .function(&quot;invoke&quot;, &amp;Interface::invoke, pure_virtual())</span><br><span class="line">        .allow_subclass&lt;InterfaceWrapper&gt;(&quot;InterfaceWrapper&quot;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allow_subclass()向接口绑定添加两个特殊方法：extend和implement。extend循序JavaScript在样式中子类。当有JavaScript对象时使用implement。并且希望使用它来实现C++接口。</p><h5 id="extend例子"><a href="#extend例子" class="headerlink" title="extend例子"></a>extend例子</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var DerivedClass = Module.Interface.extend(&quot;Interface&quot;, &#123;</span><br><span class="line">    // __construct and __destruct are optional. They are included</span><br><span class="line">    // in this example for illustration purposes.</span><br><span class="line">    // If you override __construct or __destruct, don&apos;t forget to </span><br><span class="line">    // call the parent implementation!</span><br><span class="line">    __construct : function() &#123;</span><br><span class="line">        this.__parent.__construct.call(this);</span><br><span class="line">    &#125;,</span><br><span class="line">    __destruct : function() &#123;</span><br><span class="line">        this.__parent.__destruct.call(this);</span><br><span class="line">    &#125;,</span><br><span class="line">    invoke : function() &#123;</span><br><span class="line">        // your code goes here</span><br><span class="line">    &#125;, </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var instance = new DerivedClass;</span><br></pre></td></tr></table></figure><h5 id="implement例子"><a href="#implement例子" class="headerlink" title="implement例子"></a>implement例子</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x &#123;</span><br><span class="line">    invoke : function(str) &#123;</span><br><span class="line">        console.log(&apos;invoking with: &apos; + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var interfaceObject = Module.Interface.implement(x);</span><br></pre></td></tr></table></figure><p>现在interfaceObject可以传递给任何接受Interface指针或引用。</p><h5 id="非抽象虚拟方法"><a href="#非抽象虚拟方法" class="headerlink" title="非抽象虚拟方法"></a>非抽象虚拟方法</h5><p>如果C++类具有非纯虚函数，则可以重写它，但不必重写。这需要一个稍微不同的包装器实现:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">    virtual void invoke(const std::string&amp; str) &#123;</span><br><span class="line">        //default implementation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct BaseWrapper : public Wrapper&lt;Base&gt; &#123;</span><br><span class="line">    EMSCRIPTEN_WRAPPER(BaseWrapper);</span><br><span class="line">    void invoke(const std::string&amp; str) &#123;</span><br><span class="line">        return call&lt;void&gt;(&quot;invoke&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(interface) &#123;</span><br><span class="line">    class_&lt;Base&gt;(&quot;Base&quot;)</span><br><span class="line">        .allow_subclass&lt;BaseWrapper&gt;(&quot;BaseWrapper&quot;)</span><br><span class="line">        .function(&quot;invoke&quot;, optional_override([](Base&amp; self, const std::)stirng&amp; str)&#123;</span><br><span class="line">            return self.Base::invoke(str);</span><br><span class="line">        &#125;))</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用JavaScript对象来实现Base时，invoke是可选择的。为了避免wrapper和JavaScript质检出现无线循环必须为invoke使用特殊的lambda绑定。</p><h5 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h5><p>基类绑定的定义如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(base_example) &#123;</span><br><span class="line">    class_&lt;BaseClass&gt;(&quot;BaseClass&quot;);</span><br><span class="line">    class_&lt;DerivedClass, base&lt;BaseClass&gt;&gt;(&quot;DerivedClass&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的任何BaseClass的成员函数可以访问DerivedClass的实例。此外，任何接受BaseClass实例的函数可以给一个DerivedClass的实例。</p><h5 id="自动向下传递"><a href="#自动向下传递" class="headerlink" title="自动向下传递"></a>自动向下传递</h5><p>如果C++类是多态的（也就是说，它有一个虚方法），那么Embind支持函数返回值的自动下传。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123; virtual ~ Base() &#125;; //the virtual makes Base and Derived Polymorphic</span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line">Base* getDerivedInstance() &#123;</span><br><span class="line">    return new Derived;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(automatic_downcasting) &#123;</span><br><span class="line">    class_&lt;Base&gt;(&quot;Base&quot;);</span><br><span class="line">    class_&lt;Derived， base&lt;Base&gt;&gt;(&quot;Derived&quot;);</span><br><span class="line">    function(&quot;getDerivedInstance&quot;, &amp;getDerivedInstance, allow_raw_pointers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JavaScript中调用Module.getDerivedInstance,返回Derived实例句柄，其中所有Derived方法是可用的。</p><h3 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h3><p>构造函数和普通函数可以在参数上重载，但是Enbind不支持基于类型的重载。指定重载是，使用select_overload()函数来选择适当的签名。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct HasOverloadedMethods &#123;</span><br><span class="line">    void foo();</span><br><span class="line">    void foo(int i);</span><br><span class="line">    void foo(float f) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(overloads) &#123;</span><br><span class="line">    class_&lt;HasOverloadedMethods&gt;(&quot;HasOverloadedMethods&quot;)</span><br><span class="line">        .function(&quot;foo&quot;, select_overload&lt;void()&gt;(&amp;HasOverloadedMethods::foo))</span><br><span class="line">        .function(&quot;foo_int&quot;, select_overload&lt;void(int)&gt;(&amp;HasOverloadedMethods::foo))</span><br><span class="line">        .function(&quot;foo_float&quot;, select_overload&lt;void(float)&gt;(&amp;HasOverloadMethods::foo))</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h3><p>直接通过例子来看一下enum是如何使用：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">enum OldStyle &#123;</span><br><span class="line">    OLD_STYLE_ONE,</span><br><span class="line">    OLD_STYLE_TWO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum class NewStyle &#123;</span><br><span class="line">    ONE,</span><br><span class="line">    TWO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(my_enum_example) &#123;</span><br><span class="line">    enum_&lt;OldStyle&gt;(&quot;OldStyle&quot;)</span><br><span class="line">        .value(&quot;ONE&quot;, OLD_STYLE_ONE)</span><br><span class="line">        .value(&quot;TWO&quot;, OLD_STYLE_TWO)</span><br><span class="line">        ;</span><br><span class="line">    enum_&lt;NewStyle&gt;(&quot;NewStyle&quot;)</span><br><span class="line">        .value(&quot;ONE&quot;, NewStyle::ONE)</span><br><span class="line">        .value(&quot;TWO&quot;, NewStyle::TWO)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个例子中，JavaScript都将枚举值作为类型的属性访问：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Module.OldStyle.ONE;</span><br><span class="line">Module.NewStyle.TWO;</span><br></pre></td></tr></table></figure><h3 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h3><p>JavaScript使用C++常数</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(my_constant_example) &#123;</span><br><span class="line">    constant(&quot;DOME_CONSTANT&quot;, SOME_CONSTANT);</span><br><span class="line">&#125;</span><br><span class="line">SOME_CONSTANT可以有任何已知的类型</span><br></pre></td></tr></table></figure><h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p>在某些情况下，将原始二进制直接公开给JavaScript代码作为类型化数组是很有价值的，这样就可以在不进行复制的情况下使用它。例如，这对于直接从堆上传大型WebGL纹理非常有用。<br>内存视图应该被视为原始指针；运行时不对生存期和有效性进行管理，而且如果修改或释放底层对象，则很容易损坏数据。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;emscripten/bind.h&gt;</span><br><span class="line">#include &lt;emscripten/val.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace emscripten;</span><br><span class="line"></span><br><span class="line">unsigned char *byteBuffer = /* ... */;</span><br><span class="line">size_t bufferLength = /* ... */;</span><br><span class="line"></span><br><span class="line">val getBytes() &#123;</span><br><span class="line">    return val(typed_memory_view(bufferLength, byteBuffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(memory_view_example) &#123;</span><br><span class="line">    function(&quot;getBytes&quot;, &amp;getBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用的JavaScript代码将在Emscripten堆中接受一个类型化数组视图：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myUint8Array = Module.getBytes()</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;POST&apos;, /* ... */);</span><br><span class="line">xhr.send(myUint8Array);</span><br></pre></td></tr></table></figure></p><p>类型化数组视图将具有适当的匹配类型，例如unsigned char 数组或指针。</p><h3 id="使用val将JavaScript转化为C"><a href="#使用val将JavaScript转化为C" class="headerlink" title="使用val将JavaScript转化为C++"></a>使用val将JavaScript转化为C++</h3><p>Embind提供C++类，emscripten::val,可以使用它们将JavaScript代码转化为C++代码。使用val可以从C++调用JavaScript对象，读取和写入他们的属性，或者强制它们使用C++值，比如bool,int或std::string.<br>线面这个例子展示了如何使用val从C++调用JavaScript的Web Audio API。<br>首先考虑如何在JavaScript中使用这个API:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Get web audio api context</span><br><span class="line">var AudioContext = window.AudioContext || window.webkitAudioContext;</span><br><span class="line"></span><br><span class="line">// Got an AudioContext: Create context and OscillatorNode</span><br><span class="line">var context = new AudioContext();</span><br><span class="line">var oscillator = context.createOscillator();</span><br><span class="line"></span><br><span class="line">// Configuring oscillator: set OscillatorNode type and frequency</span><br><span class="line">oscillator.type = &apos;tiangle&apos;;</span><br><span class="line">oscillator.frequency.value = 261.63; // value in hertz -middle C</span><br><span class="line"></span><br><span class="line">// Playing</span><br><span class="line">oscillator.connect(context.destination);</span><br><span class="line">oscillator.start();</span><br><span class="line"></span><br><span class="line">// All done!</span><br></pre></td></tr></table></figure></p><p>使用val,可以将这段代码转化为C++:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;emscripten/val.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace emscripten;</span><br><span class="line"></span><br><span class="line">ing main() &#123;</span><br><span class="line">    val AudioContext = val::global(&quot;AudioContext&quot;);</span><br><span class="line">    if (!AudioContext.as&lt;bool&gt;()) &#123;</span><br><span class="line">        printf(&quot;No global AudioContext, trying webkitAudioContext\n&quot;);</span><br><span class="line">        AudioContext = val::global(&quot;webkitAudioContext&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Got an AudioContext\n&quot;);</span><br><span class="line">    val context = AudioContext.new_();</span><br><span class="line">    val oscillator = context.call&lt;val&gt;(&quot;createOscillator&quot;);</span><br><span class="line">    val oscillator = context.call&lt;val&gt;(&quot;createOscillator&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Configuring oscillator\n&quot;);</span><br><span class="line">    oscillator.set(&quot;type&quot;, val(&quot;triangle&quot;));</span><br><span class="line">    oscillator[&quot;frequency&quot;].set(&quot;value&quot;, val(261.63)); //Middle C</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Playing\n&quot;);</span><br><span class="line">    oscillator.call&lt;void&gt;(&quot;connect&quot;, context[&quot;destination&quot;]);</span><br><span class="line">    oscillator.call&lt;void&gt;(&quot;start&quot;, 0);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;All done!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们首先使用global()来获取AudioContext全局对象符号，如果AudioContext不存在则获取webkitAudioContext。然后使用new_()来创建context,通过context我们可以创建oscillator,再次使用val来set它的属性，然后播放音调。<br>该示例可以在Linux/MacOSX终端上编译：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./emcc -O2 -Wall -Werror --bind -o oscillator.html oscillator.cpp</span><br></pre></td></tr></table></figure></p><h3 id="内建类型转换"><a href="#内建类型转换" class="headerlink" title="内建类型转换"></a>内建类型转换</h3><p>Embind提供了标准C++类型的转换：</p><table><thead><tr><th>C++类型</th><th>JavaScript类型</th></tr></thead><tbody><tr><td>void</td><td>undefined</td></tr><tr><td>bool</td><td>true or false</td></tr><tr><td>char</td><td>Number</td></tr><tr><td>signed char</td><td>Number</td></tr><tr><td>unsigned char</td><td>Number</td></tr><tr><td>short</td><td>Number</td></tr><tr><td>unsigned short</td><td>Number</td></tr><tr><td>int</td><td>Number</td></tr><tr><td>unsigned int</td><td>Number</td></tr><tr><td>long</td><td>Number</td></tr><tr><td>unsigned long</td><td>Number</td></tr><tr><td>float</td><td>Number</td></tr><tr><td>double</td><td>Number</td></tr><tr><td>std::string</td><td>ArrayBuffer, Uint8Array, Uint8ClampedArray, Int8Array, or String</td></tr><tr><td>std::wstring</td><td>String(UTF-16 code units)</td></tr><tr><td>emscritpen::val</td><td>anything</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Embind用于将C++函数和类绑定到javascript,这样编译的代码就可以通过javascript来调用&lt;br&gt;本文介绍如何使用EMSCRIPTEN_BINDINGS()块来为函数、类、值类型、指针（包括原始指针和智能指针）、枚举和常量创建绑定，以及如何为可以在javascript中重写的抽象类创建绑定。还简要解释了如何管理传递给javascript的C++对象句柄的内存&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="WebAssembly" scheme="http://liuyangshuo.com/categories/WebAssembly/"/>
    
    
      <category term="WebAssembly" scheme="http://liuyangshuo.com/tags/WebAssembly/"/>
    
      <category term="Emscripten" scheme="http://liuyangshuo.com/tags/Emscripten/"/>
    
      <category term="Embind" scheme="http://liuyangshuo.com/tags/Embind/"/>
    
  </entry>
  
  <entry>
    <title>shell 多线程</title>
    <link href="http://liuyangshuo.com/2018/10/21/shell_multi_thread/"/>
    <id>http://liuyangshuo.com/2018/10/21/shell_multi_thread/</id>
    <published>2018-10-21T02:46:00.000Z</published>
    <updated>2018-10-23T13:40:31.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>如果完成一个linux任务，需要多条命令的话，我们通常将这些命令写成一个shell文件，shell脚本也就是一系列命令的集合。但是默认情况下这些命令时按顺序执行的，也就是说下一条命令会等待上一条命令执行完再执行。那么如何实现命令的并行执行呢？首先我们会想到将命令或任务放到后台去执行，这样确实可以实现命令的并行运行。但是如果命令太多，放入后台可能会影响系统其它程序的运行。怎么对命令的执行进行控制，达到我们所认识的”多线程的效果”，这就是下文所介绍的shell”多线程”的实现。<br><a id="more"></a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>下面我们通过对比一个实例来说明为什么使用”多线程”以及如何实现，假设并发检测1000台web服务器状态。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">start_time=`date +%s`   #定义任务开始运行的时间</span><br><span class="line">num_server=1000</span><br><span class="line">for num in `seq $num_server`    #seq命令如果后跟一个参数则将从1到这个数的所有整数都列出来，当然还可以跟两到三个参数</span><br><span class="line">do</span><br><span class="line">    sleep 1             #使用sleep 1来模仿检测一台服务器所花费的时间</span><br><span class="line">    echo &apos;success &apos;$i</span><br><span class="line">done</span><br><span class="line">stop_time=`date +%s`    #定义任务运行结束的时间</span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`s&quot; #总的任务所花费的时间</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success 1</span><br><span class="line">success 2</span><br><span class="line">success 3</span><br><span class="line">...</span><br><span class="line">success 998</span><br><span class="line">success 999</span><br><span class="line">success 1000</span><br><span class="line">TIME:1000s</span><br></pre></td></tr></table></figure></p><p>通过上面这个例子能够发现该脚本有一个很明显的弊端就是运行时间很长，这也正是为什么要使用”多线程”的原因。那么我们来看一下将任务放入后台运行情况<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">start_time=`date +%s`   #定义任务开始运行的时间</span><br><span class="line">num_server=1000</span><br><span class="line">for num in `seq $num_server`    #seq命令如果后跟一个参数则将从1到这个数的所有整数都列出来，当然还可以跟两到三个参数</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">    sleep 1             #使用sleep 1来模仿检测一台服务器所花费的时间</span><br><span class="line">    echo &apos;success &apos;$num</span><br><span class="line">&#125;&amp;                      #后面加一个&amp;符号，表示将任务放入后台运行，不会阻塞下一次for循环</span><br><span class="line">done</span><br><span class="line">wait                    #wait的命令时等待上面的命令运行完成后再向下执行，不然后面的计算时间有可能先输出出来</span><br><span class="line">stop_time=`date +%s`    #定义任务运行结束的时间</span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`s&quot; #总的任务所花费的时间</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success 1</span><br><span class="line">success 2</span><br><span class="line">success 3</span><br><span class="line">...</span><br><span class="line">success 998</span><br><span class="line">success 999</span><br><span class="line">success 1000</span><br><span class="line">TIME:11s</span><br></pre></td></tr></table></figure></p><p>从运行所花费的时间来看较上一个脚本要快很多，我的计算机是用了11s。计算机配置不同运行所需时间也不一样。按照理想状态，脚本运行所需要的时间应该不超过2s，而且在程序运行过程中，能够明显听到计算机的风扇发出的声音，可见是非常消耗资源的。这样给操作系统造成的压力就非常大，如何根据控制同时运行这么多的任务呢？<br>可以借鉴c++中使用多线程的方法，就是通过一个队列来控制，那么这个队列则可以使用系统中的管道来实现。虽然管道和队列有相同的特性，即按顺序存取，没有阻塞，但是和队列不同的是只能往管道文件中放入一段数据，如果没有及时取出就会阻塞。如何往管道里放多条数据呢，这就要用到文件描述符，代码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">start_time=`date +%s`   #定义任务开始运行的时间</span><br><span class="line">[ -e /tmp/fd1 ] || mkfifo /tmp/fd1  #创建管道</span><br><span class="line">exec 3&lt;&gt;/tmp/fd1        #创建文件描述符并关以可读(&lt;)可写(&gt;)的方式关联管道文件,这里之所以选择3作为文件描述符，是因为习惯上，0为标准输入，1为标准输出，2为标准错误输出</span><br><span class="line">rm -rf /tmp/fd1         #关联后的文件描述符拥有管道文件的所有特性，这个时候可以删除管道文件</span><br><span class="line">for ((i=1;i&lt;=10;i++))</span><br><span class="line">do</span><br><span class="line">    echo &gt;&amp;3        #&amp;3表示引用文件描述符3,代表向管道里放入一把钥匙</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">num_server=1000</span><br><span class="line">for num in `seq $num_server`    #seq命令如果后跟一个参数则将从1到这个数的所有整数都列出来，当然还可以跟两到三个参数</span><br><span class="line">do</span><br><span class="line">read -u3            #代表从管道中取出一把钥匙</span><br><span class="line">&#123;</span><br><span class="line">    sleep 1             #使用sleep 1来模仿检测一台服务器所花费的时间</span><br><span class="line">    echo &apos;success &apos;$num</span><br><span class="line">    echo &gt;&amp;3            #代表命令执行后，将钥匙放回管道中</span><br><span class="line">&#125;&amp;                      #后面加一个&amp;符号，表示将任务放入后台运行，不会阻塞下一次for循环</span><br><span class="line">done</span><br><span class="line">wait                    #wait的命令时等待上面的命令运行完成后再向下执行，不然后面的计算时间有可能先输出出来</span><br><span class="line">stop_time=`date +%s`    #定义任务运行结束的时间</span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`s&quot; #总的任务所花费的时间</span><br><span class="line">exec 3&lt;&amp;-           #关闭文件描述符的读</span><br><span class="line">exec 3&gt;&amp;-           #关闭文件描述符的写</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success 1</span><br><span class="line">success 2</span><br><span class="line">success 3</span><br><span class="line">...</span><br><span class="line">success 998</span><br><span class="line">success 999</span><br><span class="line">success 1000</span><br><span class="line">TIME:107s</span><br></pre></td></tr></table></figure></p><p>运行时间为107s,没有第二种方案运行的快，但比第一种方案快了很多，该方案实现了同一时间内最多只有10个线程的并发，既提高了效率，有实现了并发控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;如果完成一个linux任务，需要多条命令的话，我们通常将这些命令写成一个shell文件，shell脚本也就是一系列命令的集合。但是默认情况下这些命令时按顺序执行的，也就是说下一条命令会等待上一条命令执行完再执行。那么如何实现命令的并行执行呢？首先我们会想到将命令或任务放到后台去执行，这样确实可以实现命令的并行运行。但是如果命令太多，放入后台可能会影响系统其它程序的运行。怎么对命令的执行进行控制，达到我们所认识的”多线程的效果”，这就是下文所介绍的shell”多线程”的实现。&lt;br&gt;
    
    </summary>
    
      <category term="shell" scheme="http://liuyangshuo.com/categories/shell/"/>
    
    
      <category term="shell" scheme="http://liuyangshuo.com/tags/shell/"/>
    
      <category term="linux" scheme="http://liuyangshuo.com/tags/linux/"/>
    
      <category term="多线程" scheme="http://liuyangshuo.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建笔记</title>
    <link href="http://liuyangshuo.com/2018/10/13/hexo_and_markdown/"/>
    <id>http://liuyangshuo.com/2018/10/13/hexo_and_markdown/</id>
    <published>2018-10-13T07:46:00.000Z</published>
    <updated>2018-10-13T14:23:56.107Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><hr><ul><li>本博客记录了我在搭建好我的博客网站后遇到的一些问题，以免日后遇到相同问题又要到处搜索，如果遇到和我相同问题的朋友也可以用作参考</li><li>在这里我将博客网站和博文的问题放在一篇文章中来统一介绍</li></ul><hr><a id="more"></a><h3 id="网站配置和主题配置"><a href="#网站配置和主题配置" class="headerlink" title="网站配置和主题配置"></a>网站配置和主题配置</h3><h4 id="博客网站配置"><a href="#博客网站配置" class="headerlink" title="博客网站配置"></a>博客网站配置</h4><hr><ul><li>找到hexo博客所在目录，打开配置文件_config.yml。下面是我所修改的一些内容,如果没有可以自己添加：</li><li>title：刘养硕的博客 //标题</li><li>subtitle: 记录工作和学习的点点滴滴  //副标题</li><li>description: 快乐生活，快乐学习 //描述</li><li>author: 刘养硕  //博主</li><li>language: zh_CN //中文语言，默认为英文，这个还要看你主题所支持的语言</li><li>还可以有keywords等选项，我的博客里面不显示就没有加</li><li>这里进行一下说明，在我打算修改博客为中文时（默认为英文），博客显示的语言不稳定，有时是英文，有时是中文，还有时会出现中文繁体，因此我没有在配置文件中修改语言选项（也就是language）。我修改的是主题文件夹下所支持的语言文件：进入到themes\aria\languages目录（aria是我所使用的主题），我对languages目录做了一下备份，然后将default.yml和zh_CN.yml以外的文件都删掉，最后修改defulet.yml中的内容为zh_CH.yml（默认为en.yml）</li></ul><hr><h4 id="修改博客的主题"><a href="#修改博客的主题" class="headerlink" title="修改博客的主题"></a>修改博客的主题</h4><hr><ul><li>在网上搜索hexo主题，进入到hexo官网主题网站，在下载之前可以先预览一下主题</li><li>找到自己喜欢的主题，进入到主题所在的github网站,复制主题的github网址。到博客的主题目录下使用git clone命令下载</li><li>下载好之后一定好阅读主题的README.md文件，里面会对该主题进行说明，至少会介绍主题配置，也就是修改博客的_config.yml文件中的theme。必要时还要下载支持该主题的一些插件，这个按照README.md中的说明操作即可</li><li>修改完博客的配置文件_config.yml之后，网站会应用该主题。如果要进一步确定网页的具体显示内容就要修改主题的配置文件，名字也是_config.yml（我的在themes\aria目录下）</li><li>修改菜单栏显示的内容，我的默认是只显示首页和归档，其余的是注释掉的。这里如果要显示其他菜单，如：分类，就将前面的注释符去掉。如果还不显示，就执行$ hexo new page “categories”命令,这时就会在source文件夹下生成一个categories文件夹。这时再启动服务就会看到网页上显示分类菜单，其他的也一样</li></ul><hr><h4 id="修改博客的头像"><a href="#修改博客的头像" class="headerlink" title="修改博客的头像"></a>修改博客的头像</h4><hr><ul><li>首先找到一张自己喜欢的图片（静态动态都可以，最好是正方形的），然后将图片放到themes\aria\source\images文件夹</li><li>同样是在主题的配置文件_config.yml中，找到avatar,如果没有就手动添加，将原来的修改为avatar: images/xiaohei2.gif。xiaohei2.gif是我的一张动态图片的名字，同样也可以修改logo的图片</li></ul><hr><h3 id="修改博文"><a href="#修改博文" class="headerlink" title="修改博文"></a>修改博文</h3><hr><ul><li>给文章添加标题使用title关键字，如title： 博客笔记</li><li>给文章添加标签使用tags，格式同上</li><li>给文章添加分类使用categories，格式同上</li><li>如果添加多个标签或分类如下图所示</li><li><img src="https://github.com/liuyangshuo/liuyangshuo.github.io/raw/master/img/tags.jpg" alt="添加多个标签"></li><li><p>在文章中插入图片，我用的是有道云笔记写markdown的。软件支持直接拖入图片，就是需要会员，所以我手动插入的。我是现将图片放到该博客的github上，首先在source目录下新建一个img文件夹，将图片放到img文件夹下，然后使用hexo d将该图片推送到github上（我这里对于本博客所对应github没有使用git push权限）。进入到你的github网站，找到该图片，然后将该图片的网址复制出来，在你想放图片位置使用:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片说明](图片所在github网址)</span><br></pre></td></tr></table></figure></li><li><p>将网址粘贴到小括号内。这时还不能显示图片，在刚才粘贴网址中找到blob,并将blob改为raw,发布文章就可以看到了</p></li><li>说明一下，在博客目录下有一个和github目录对应的public文件夹，在每次执行hexo cleand命令时该文件夹都会被清空。在执行hexo g时优惠重新生成该文件夹，然后使用hexo d将public文件夹中的额内容推送到github上。我刚开始不了解，就将图片放到public目录下的images文件夹，结果每次发布就会丢失图片。正确的做法是放到source的一个文件夹或者是主题下的images文件夹，目的是在生成public文件夹时能够找到该图片。我之所以不放到主题下的images文件夹，是因为我不想文章和主题相关联，这样之后在更换主题时还要再修改图片位置</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;本博客记录了我在搭建好我的博客网站后遇到的一些问题，以免日后遇到相同问题又要到处搜索，如果遇到和我相同问题的朋友也可以用作参考&lt;/li&gt;
&lt;li&gt;在这里我将博客网站和博文的问题放在一篇文章中来统一介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="博客" scheme="http://liuyangshuo.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://liuyangshuo.com/tags/hexo/"/>
    
      <category term="markdown" scheme="http://liuyangshuo.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>C/C++知识总结之abs函数</title>
    <link href="http://liuyangshuo.com/2018/10/10/C++_abs/"/>
    <id>http://liuyangshuo.com/2018/10/10/C++_abs/</id>
    <published>2018-10-10T13:25:00.000Z</published>
    <updated>2018-10-11T14:48:48.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h3><hr><ul><li>abs函数存在于不止一个库中，使用哪个库中的abs函数就可以包含哪个头文件</li><li>其中在c标准库stdlib.h中abs函数只接受整型或长整型，在c98标准中参数类型可以是int或long int类型；c11标准中还可以是long long int类型</li><li>在数学函数库cmath/math.h中，在c++98标准中abs可接受的参数类型为double/float/long double；在c++11中还可以接受各种整型参数。abs还可以写成fabs，这两个用法是一样的，labs则只接受long int类型的参数。在c++11中头文件可以写cmath,c++98只能写math.h</li><li>abs函数的返回值和参数类型保持一致</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;abs函数&quot;&gt;&lt;a href=&quot;#abs函数&quot; class=&quot;headerlink&quot; title=&quot;abs函数&quot;&gt;&lt;/a&gt;abs函数&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;abs函数存在于不止一个库中，使用哪个库中的abs函数就可以包含哪个头文件&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="C/C++" scheme="http://liuyangshuo.com/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://liuyangshuo.com/tags/C-C/"/>
    
      <category term="abs" scheme="http://liuyangshuo.com/tags/abs/"/>
    
  </entry>
  
  <entry>
    <title>git 学习</title>
    <link href="http://liuyangshuo.com/2018/10/06/git_command/"/>
    <id>http://liuyangshuo.com/2018/10/06/git_command/</id>
    <published>2018-10-06T09:53:11.000Z</published>
    <updated>2018-10-13T08:14:55.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本库简介"><a href="#版本库简介" class="headerlink" title="版本库简介"></a>版本库简介</h3><hr><ul><li>cvs和svn都是集中式版本控制系统，git是分布式版本控制系统</li><li>集中式一旦中央服务器坏掉，使用该版本库的所有员工都无法工作</li><li>而分布式每个人的电脑都相当于一个完整的版本库，无需联网一样工作，分布式交集中式的安全性要高很多</li><li>本文介绍git使用的一些常用的命令</li></ul><hr><a id="more"></a><p><img src="https://github.com/liuyangshuo/liuyangshuo.github.io/raw/master/img/git.jpg" alt="git数据传输指令"></p><h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"lys"</span></span><br><span class="line">$ git config --global user.email <span class="string">"liu_yangshuo@163.com"</span></span><br></pre></td></tr></table></figure><h3 id="git获取版本库"><a href="#git获取版本库" class="headerlink" title="git获取版本库"></a>git获取版本库</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> http://xxxxxx</span><br></pre></td></tr></table></figure><h3 id="git初始化一个新仓库"><a href="#git初始化一个新仓库" class="headerlink" title="git初始化一个新仓库"></a>git初始化一个新仓库</h3><p>新建一个文件夹，然后在文件夹下执行：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></p><p>执行完命令就会在该文件夹下生成.git文件夹</p><h3 id="git代码提交流程"><a href="#git代码提交流程" class="headerlink" title="git代码提交流程"></a>git代码提交流程</h3><hr><ol><li>新建或修改文件</li><li>使用 git add 命令将文件添加到缓存区</li><li>使用 git commit 将修改文件提交到本地代码库</li><li>使用 git push 将本地文件同步到远程代码库</li></ol><hr><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status  //使用该命令可以判断git代码提交流程执行到哪一步，该命令显示当前的状态信息</span><br><span class="line">$ git diff    //该命令会显示当前已修改但是还没加入缓存区的内容</span><br><span class="line">$ git diff --cached   //该命令显示使用git add加入到缓存区中的文件内容</span><br><span class="line">$ git commit -m <span class="string">"git log"</span>    //将加入到缓存区中的内容提交到本地版本库，</span><br><span class="line">$ git commit -a -m <span class="string">"git log"</span>  //如果不是用git add那么这个命令只会将修改的文件提交到版本库，不会提交新建文件</span><br><span class="line">$ git branch  //查看所有分支，以及当前所在分支</span><br><span class="line">$ git branch branch_01_01 //新建一个分支</span><br><span class="line">$ git checkout master //切换分支</span><br><span class="line">$ git merge -m <span class="string">'merge branch_01_01 branch'</span> branch_01_01    //将branch_01_01分支合并到当前分支</span><br><span class="line">$ git branch -d branch_01_01  //删除分支branch_01_01,该命令只能删除已经合并的分支，如果强制删除某个分支使用-D参数</span><br><span class="line">$ git reset --head HEAD^  //撤销合并的内容</span><br><span class="line">$ git <span class="built_in">log</span> //查看所有日志</span><br><span class="line">$ git <span class="built_in">log</span> v1.1... main.cpp /<span class="built_in">source</span> //该命令显示从v1.1开发<span class="built_in">source</span>目录下所有main.cpp文件的修改</span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span>  //该命令显示日志更详细的内容</span><br><span class="line">$ git <span class="built_in">log</span> --pretty=[online/medium/short/full/fuller/email/raw] //格式化日志输出</span><br><span class="line">$ git <span class="built_in">log</span> --graph --pretty=online   //--graph选项用来可视化日志</span><br><span class="line">$ git diff master <span class="built_in">test</span>  //比较分支<span class="built_in">test</span>和主线master的区别</span><br><span class="line">$ git diff <span class="built_in">test</span> //比较<span class="built_in">test</span>分支和当前分支的差别</span><br><span class="line">$ git diff <span class="built_in">test</span> file1   //比较分支<span class="built_in">test</span>中file1和当前分支file1的差别</span><br><span class="line">$ git diff <span class="built_in">test</span> --<span class="built_in">stat</span>  //统计都有哪些文件，哪些行有差别</span><br><span class="line">$ git tag tag-1 b1a2f004 //打一个名为tag-1的标签，b1a2f004为commit名称的前8位</span><br><span class="line">$ git tag -a tag-2 b1a2f004 -m <span class="string">"tag 2"</span>  //创建一个标签对象，并添加注释</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;版本库简介&quot;&gt;&lt;a href=&quot;#版本库简介&quot; class=&quot;headerlink&quot; title=&quot;版本库简介&quot;&gt;&lt;/a&gt;版本库简介&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;cvs和svn都是集中式版本控制系统，git是分布式版本控制系统&lt;/li&gt;
&lt;li&gt;集中式一旦中央服务器坏掉，使用该版本库的所有员工都无法工作&lt;/li&gt;
&lt;li&gt;而分布式每个人的电脑都相当于一个完整的版本库，无需联网一样工作，分布式交集中式的安全性要高很多&lt;/li&gt;
&lt;li&gt;本文介绍git使用的一些常用的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://liuyangshuo.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://liuyangshuo.com/tags/git/"/>
    
      <category term="开发工具" scheme="http://liuyangshuo.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://liuyangshuo.com/2018/06/14/hello-world/"/>
    <id>http://liuyangshuo.com/2018/06/14/hello-world/</id>
    <published>2018-06-14T13:55:27.279Z</published>
    <updated>2018-06-14T13:55:27.279Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
