<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>shell 多线程</title>
      <link href="/2018/10/21/shell_multi_thread/"/>
      <url>/2018/10/21/shell_multi_thread/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>如果完成一个linux任务，需要多条命令的话，我们通常将这些命令写成一个shell文件，shell脚本也就是一系列命令的集合。但是默认情况下这些命令时按顺序执行的，也就是说下一条命令会等待上一条命令执行完再执行。那么如何实现命令的并行执行呢？首先我们会想到将命令或任务放到后台去执行，这样确实可以实现命令的并行运行。但是如果命令太多，放入后台可能会影响系统其它程序的运行。怎么对命令的执行进行控制，达到我们所认识的”多线程的效果”，这就是下文所介绍的shell”多线程”的实现。<br><a id="more"></a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>下面我们通过对比一个实例来说明为什么使用”多线程”以及如何实现，假设并发检测1000台web服务器状态。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">start_time=`date +%s`   #定义任务开始运行的时间</span><br><span class="line">num_server=1000</span><br><span class="line">for num in `seq $num_server`    #seq命令如果后跟一个参数则将从1到这个数的所有整数都列出来，当然还可以跟两到三个参数</span><br><span class="line">do</span><br><span class="line">    sleep 1             #使用sleep 1来模仿检测一台服务器所花费的时间</span><br><span class="line">    echo &apos;success &apos;$i</span><br><span class="line">done</span><br><span class="line">stop_time=`date +%s`    #定义任务运行结束的时间</span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`s&quot; #总的任务所花费的时间</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success 1</span><br><span class="line">success 2</span><br><span class="line">success 3</span><br><span class="line">...</span><br><span class="line">success 998</span><br><span class="line">success 999</span><br><span class="line">success 1000</span><br><span class="line">TIME:1000s</span><br></pre></td></tr></table></figure></p><p>通过上面这个例子能够发现该脚本有一个很明显的弊端就是运行时间很长，这也正是为什么要使用”多线程”的原因。那么我们来看一下将任务放入后台运行情况<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">start_time=`date +%s`   #定义任务开始运行的时间</span><br><span class="line">num_server=1000</span><br><span class="line">for num in `seq $num_server`    #seq命令如果后跟一个参数则将从1到这个数的所有整数都列出来，当然还可以跟两到三个参数</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">    sleep 1             #使用sleep 1来模仿检测一台服务器所花费的时间</span><br><span class="line">    echo &apos;success &apos;$num</span><br><span class="line">&#125;&amp;                      #后面加一个&amp;符号，表示将任务放入后台运行，不会阻塞下一次for循环</span><br><span class="line">done</span><br><span class="line">wait                    #wait的命令时等待上面的命令运行完成后再向下执行，不然后面的计算时间有可能先输出出来</span><br><span class="line">stop_time=`date +%s`    #定义任务运行结束的时间</span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`s&quot; #总的任务所花费的时间</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success 1</span><br><span class="line">success 2</span><br><span class="line">success 3</span><br><span class="line">...</span><br><span class="line">success 998</span><br><span class="line">success 999</span><br><span class="line">success 1000</span><br><span class="line">TIME:11s</span><br></pre></td></tr></table></figure></p><p>从运行所花费的时间来看较上一个脚本要快很多，我的计算机是用了11s。计算机配置不同运行所需时间也不一样。按照理想状态，脚本运行所需要的时间应该不超过2s，而且在程序运行过程中，能够明显听到计算机的风扇发出的声音，可见是非常消耗资源的。这样给操作系统造成的压力就非常大，如何根据控制同时运行这么多的任务呢？<br>可以借鉴c++中使用多线程的方法，就是通过一个队列来控制，那么这个队列则可以使用系统中的管道来实现。虽然管道和队列有相同的特性，即按顺序存取，没有阻塞，但是和队列不同的是只能往管道文件中放入一段数据，如果没有及时取出就会阻塞。如何往管道里放多条数据呢，这就要用到文件描述符，代码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">start_time=`date +%s`   #定义任务开始运行的时间</span><br><span class="line">[ -e /tmp/fd1 ] || mkfifo /tmp/fd1  #创建管道</span><br><span class="line">exec 3&lt;&gt;/tmp/fd1        #创建文件描述符并关以可读(&lt;)可写(&gt;)的方式关联管道文件,这里之所以选择3作为文件描述符，是因为习惯上，0为标准输入，1为标准输出，2为标准错误输出</span><br><span class="line">rm -rf /tmp/fd1         #关联后的文件描述符拥有管道文件的所有特性，这个时候可以删除管道文件</span><br><span class="line">for ((i=1;i&lt;=10;i++))</span><br><span class="line">do</span><br><span class="line">    echo &gt;&amp;3        #&amp;3表示引用文件描述符3,代表向管道里放入一把钥匙</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">num_server=1000</span><br><span class="line">for num in `seq $num_server`    #seq命令如果后跟一个参数则将从1到这个数的所有整数都列出来，当然还可以跟两到三个参数</span><br><span class="line">do</span><br><span class="line">read -u3            #代表从管道中取出一把钥匙</span><br><span class="line">&#123;</span><br><span class="line">    sleep 1             #使用sleep 1来模仿检测一台服务器所花费的时间</span><br><span class="line">    echo &apos;success &apos;$num</span><br><span class="line">    echo &gt;&amp;3            #代表命令执行后，将钥匙放回管道中</span><br><span class="line">&#125;&amp;                      #后面加一个&amp;符号，表示将任务放入后台运行，不会阻塞下一次for循环</span><br><span class="line">done</span><br><span class="line">wait                    #wait的命令时等待上面的命令运行完成后再向下执行，不然后面的计算时间有可能先输出出来</span><br><span class="line">stop_time=`date +%s`    #定义任务运行结束的时间</span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`s&quot; #总的任务所花费的时间</span><br><span class="line">exec 3&lt;&amp;-           #关闭文件描述符的读</span><br><span class="line">exec 3&gt;&amp;-           #关闭文件描述符的写</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success 1</span><br><span class="line">success 2</span><br><span class="line">success 3</span><br><span class="line">...</span><br><span class="line">success 998</span><br><span class="line">success 999</span><br><span class="line">success 1000</span><br><span class="line">TIME:107s</span><br></pre></td></tr></table></figure></p><p>运行时间为107s,没有第二种方案运行的快，但比第一种方案快了很多，该方案实现了同一时间内最多只有10个线程的并发，既提高了效率，有实现了并发控制。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客搭建笔记</title>
      <link href="/2018/10/13/hexo_and_markdown/"/>
      <url>/2018/10/13/hexo_and_markdown/</url>
      
        <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><hr><ul><li>本博客记录了我在搭建好我的博客网站后遇到的一些问题，以免日后遇到相同问题又要到处搜索，如果遇到和我相同问题的朋友也可以用作参考</li><li>在这里我将博客网站和博文的问题放在一篇文章中来统一介绍</li></ul><hr><a id="more"></a><h3 id="网站配置和主题配置"><a href="#网站配置和主题配置" class="headerlink" title="网站配置和主题配置"></a>网站配置和主题配置</h3><h4 id="博客网站配置"><a href="#博客网站配置" class="headerlink" title="博客网站配置"></a>博客网站配置</h4><hr><ul><li>找到hexo博客所在目录，打开配置文件_config.yml。下面是我所修改的一些内容,如果没有可以自己添加：</li><li>title：刘养硕的博客 //标题</li><li>subtitle: 记录工作和学习的点点滴滴  //副标题</li><li>description: 快乐生活，快乐学习 //描述</li><li>author: 刘养硕  //博主</li><li>language: zh_CN //中文语言，默认为英文，这个还要看你主题所支持的语言</li><li>还可以有keywords等选项，我的博客里面不显示就没有加</li><li>这里进行一下说明，在我打算修改博客为中文时（默认为英文），博客显示的语言不稳定，有时是英文，有时是中文，还有时会出现中文繁体，因此我没有在配置文件中修改语言选项（也就是language）。我修改的是主题文件夹下所支持的语言文件：进入到themes\aria\languages目录（aria是我所使用的主题），我对languages目录做了一下备份，然后将default.yml和zh_CN.yml以外的文件都删掉，最后修改defulet.yml中的内容为zh_CH.yml（默认为en.yml）</li></ul><hr><h4 id="修改博客的主题"><a href="#修改博客的主题" class="headerlink" title="修改博客的主题"></a>修改博客的主题</h4><hr><ul><li>在网上搜索hexo主题，进入到hexo官网主题网站，在下载之前可以先预览一下主题</li><li>找到自己喜欢的主题，进入到主题所在的github网站,复制主题的github网址。到博客的主题目录下使用git clone命令下载</li><li>下载好之后一定好阅读主题的README.md文件，里面会对该主题进行说明，至少会介绍主题配置，也就是修改博客的_config.yml文件中的theme。必要时还要下载支持该主题的一些插件，这个按照README.md中的说明操作即可</li><li>修改完博客的配置文件_config.yml之后，网站会应用该主题。如果要进一步确定网页的具体显示内容就要修改主题的配置文件，名字也是_config.yml（我的在themes\aria目录下）</li><li>修改菜单栏显示的内容，我的默认是只显示首页和归档，其余的是注释掉的。这里如果要显示其他菜单，如：分类，就将前面的注释符去掉。如果还不显示，就执行$ hexo new page “categories”命令,这时就会在source文件夹下生成一个categories文件夹。这时再启动服务就会看到网页上显示分类菜单，其他的也一样</li></ul><hr><h4 id="修改博客的头像"><a href="#修改博客的头像" class="headerlink" title="修改博客的头像"></a>修改博客的头像</h4><hr><ul><li>首先找到一张自己喜欢的图片（静态动态都可以，最好是正方形的），然后将图片放到themes\aria\source\images文件夹</li><li>同样是在主题的配置文件_config.yml中，找到avatar,如果没有就手动添加，将原来的修改为avatar: images/xiaohei2.gif。xiaohei2.gif是我的一张动态图片的名字，同样也可以修改logo的图片</li></ul><hr><h3 id="修改博文"><a href="#修改博文" class="headerlink" title="修改博文"></a>修改博文</h3><hr><ul><li>给文章添加标题使用title关键字，如title： 博客笔记</li><li>给文章添加标签使用tags，格式同上</li><li>给文章添加分类使用categories，格式同上</li><li>如果添加多个标签或分类如下图所示</li><li><img src="https://github.com/liuyangshuo/liuyangshuo.github.io/raw/master/img/tags.jpg" alt="添加多个标签"></li><li><p>在文章中插入图片，我用的是有道云笔记写markdown的。软件支持直接拖入图片，就是需要会员，所以我手动插入的。我是现将图片放到该博客的github上，首先在source目录下新建一个img文件夹，将图片放到img文件夹下，然后使用hexo d将该图片推送到github上（我这里对于本博客所对应github没有使用git push权限）。进入到你的github网站，找到该图片，然后将该图片的网址复制出来，在你想放图片位置使用:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片说明](图片所在github网址)</span><br></pre></td></tr></table></figure></li><li><p>将网址粘贴到小括号内。这时还不能显示图片，在刚才粘贴网址中找到blob,并将blob改为raw,发布文章就可以看到了</p></li><li>说明一下，在博客目录下有一个和github目录对应的public文件夹，在每次执行hexo cleand命令时该文件夹都会被清空。在执行hexo g时优惠重新生成该文件夹，然后使用hexo d将public文件夹中的额内容推送到github上。我刚开始不了解，就将图片放到public目录下的images文件夹，结果每次发布就会丢失图片。正确的做法是放到source的一个文件夹或者是主题下的images文件夹，目的是在生成public文件夹时能够找到该图片。我之所以不放到主题下的images文件夹，是因为我不想文章和主题相关联，这样之后在更换主题时还要再修改图片位置</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++知识总结之abs函数</title>
      <link href="/2018/10/10/C++_abs/"/>
      <url>/2018/10/10/C++_abs/</url>
      
        <content type="html"><![CDATA[<h3 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h3><hr><ul><li>abs函数存在于不止一个库中，使用哪个库中的abs函数就可以包含哪个头文件</li><li>其中在c标准库stdlib.h中abs函数只接受整型或长整型，在c98标准中参数类型可以是int或long int类型；c11标准中还可以是long long int类型</li><li>在数学函数库cmath/math.h中，在c++98标准中abs可接受的参数类型为double/float/long double；在c++11中还可以接受各种整型参数。abs还可以写成fabs，这两个用法是一样的，labs则只接受long int类型的参数。在c++11中头文件可以写cmath,c++98只能写math.h</li><li>abs函数的返回值和参数类型保持一致</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> abs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git 学习</title>
      <link href="/2018/10/06/git_command/"/>
      <url>/2018/10/06/git_command/</url>
      
        <content type="html"><![CDATA[<h3 id="版本库简介"><a href="#版本库简介" class="headerlink" title="版本库简介"></a>版本库简介</h3><hr><ul><li>cvs和svn都是集中式版本控制系统，git是分布式版本控制系统</li><li>集中式一旦中央服务器坏掉，使用该版本库的所有员工都无法工作</li><li>而分布式每个人的电脑都相当于一个完整的版本库，无需联网一样工作，分布式交集中式的安全性要高很多</li><li>本文介绍git使用的一些常用的命令</li></ul><hr><a id="more"></a><p><img src="https://github.com/liuyangshuo/liuyangshuo.github.io/raw/master/img/git.jpg" alt="git数据传输指令"></p><h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"lys"</span></span><br><span class="line">$ git config --global user.email <span class="string">"liu_yangshuo@163.com"</span></span><br></pre></td></tr></table></figure><h3 id="git获取版本库"><a href="#git获取版本库" class="headerlink" title="git获取版本库"></a>git获取版本库</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> http://xxxxxx</span><br></pre></td></tr></table></figure><h3 id="git初始化一个新仓库"><a href="#git初始化一个新仓库" class="headerlink" title="git初始化一个新仓库"></a>git初始化一个新仓库</h3><p>新建一个文件夹，然后在文件夹下执行：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></p><p>执行完命令就会在该文件夹下生成.git文件夹</p><h3 id="git代码提交流程"><a href="#git代码提交流程" class="headerlink" title="git代码提交流程"></a>git代码提交流程</h3><hr><ol><li>新建或修改文件</li><li>使用 git add 命令将文件添加到缓存区</li><li>使用 git commit 将修改文件提交到本地代码库</li><li>使用 git push 将本地文件同步到远程代码库</li></ol><hr><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status  //使用该命令可以判断git代码提交流程执行到哪一步，该命令显示当前的状态信息</span><br><span class="line">$ git diff    //该命令会显示当前已修改但是还没加入缓存区的内容</span><br><span class="line">$ git diff --cached   //该命令显示使用git add加入到缓存区中的文件内容</span><br><span class="line">$ git commit -m <span class="string">"git log"</span>    //将加入到缓存区中的内容提交到本地版本库，</span><br><span class="line">$ git commit -a -m <span class="string">"git log"</span>  //如果不是用git add那么这个命令只会将修改的文件提交到版本库，不会提交新建文件</span><br><span class="line">$ git branch  //查看所有分支，以及当前所在分支</span><br><span class="line">$ git branch branch_01_01 //新建一个分支</span><br><span class="line">$ git checkout master //切换分支</span><br><span class="line">$ git merge -m <span class="string">'merge branch_01_01 branch'</span> branch_01_01    //将branch_01_01分支合并到当前分支</span><br><span class="line">$ git branch -d branch_01_01  //删除分支branch_01_01,该命令只能删除已经合并的分支，如果强制删除某个分支使用-D参数</span><br><span class="line">$ git reset --head HEAD^  //撤销合并的内容</span><br><span class="line">$ git <span class="built_in">log</span> //查看所有日志</span><br><span class="line">$ git <span class="built_in">log</span> v1.1... main.cpp /<span class="built_in">source</span> //该命令显示从v1.1开发<span class="built_in">source</span>目录下所有main.cpp文件的修改</span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span>  //该命令显示日志更详细的内容</span><br><span class="line">$ git <span class="built_in">log</span> --pretty=[online/medium/short/full/fuller/email/raw] //格式化日志输出</span><br><span class="line">$ git <span class="built_in">log</span> --graph --pretty=online   //--graph选项用来可视化日志</span><br><span class="line">$ git diff master <span class="built_in">test</span>  //比较分支<span class="built_in">test</span>和主线master的区别</span><br><span class="line">$ git diff <span class="built_in">test</span> //比较<span class="built_in">test</span>分支和当前分支的差别</span><br><span class="line">$ git diff <span class="built_in">test</span> file1   //比较分支<span class="built_in">test</span>中file1和当前分支file1的差别</span><br><span class="line">$ git diff <span class="built_in">test</span> --<span class="built_in">stat</span>  //统计都有哪些文件，哪些行有差别</span><br><span class="line">$ git tag tag-1 b1a2f004 //打一个名为tag-1的标签，b1a2f004为commit名称的前8位</span><br><span class="line">$ git tag -a tag-2 b1a2f004 -m <span class="string">"tag 2"</span>  //创建一个标签对象，并添加注释</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/14/hello-world/"/>
      <url>/2018/06/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
