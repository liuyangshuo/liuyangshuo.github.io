<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C 库函数</title>
      <link href="/2019/04/28/c_function/"/>
      <url>/2019/04/28/c_function/</url>
      
        <content type="html"><![CDATA[<h3 id="strtol"><a href="#strtol" class="headerlink" title="strtol"></a>strtol</h3><p>long int strtol(const char *nptr, char **endptr, int base)</p><p>strtol()会将nptr指向的字符串，根据参数base，按权转化为long int, 然后返回这个值。</p><p>参数base的范围为2~36,和0；它决定了字符串以被转换为整数的权值。</p><p>可以被转换的合法字符依据base而定，举例来说，当base为2时，合法字符为‘0’，‘1’；</p><p>base为8时，合法字符为‘0’，‘1’，……‘7’；</p><p>base为10时，合法字符为‘0’，‘1’，……‘9’；</p><p>base 为16时，合法字符为‘0’，‘1’，……‘9’，‘a’，……‘f’；</p><p>base为24时，合法字符为‘0’，……‘9’，‘a’，……‘n’；</p><p>base为36时，合法字符为‘0’，……‘9’，‘a’，……‘z’；</p><p>其中，不区分大小写，比如，‘A’和‘a’会都会被转化为10。</p><p>当字符合法时，‘0’，……‘9’依次被转换为十进制的0～9，‘a’，……‘z’一次北转换为十进制的10～35。</p><p>strtol()函数检测到第一个非法字符时，立即停止检测，其后的所有字符都会被当作非法字符处理。合法字符串会被转换为long int，作为函数的返回值。</p><p>非法字符串，即从第一个非法字符的地址，被赋给*endptr。</p><p>*<em>endptr是个双重指针，即指针的指针。strtol()函数就是通过它改变</em>endptr的值，即把第一个非法字符的地址传给endptr。</p><p>下面看几个例子:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char buffer[20]=&quot;10379cend$3&quot;;</span><br><span class="line">char *stop;</span><br><span class="line">printf(&quot;%d\n&quot;,strtol(buffer, &amp;stop, 2));</span><br><span class="line">printf(&quot;%s\n&quot;, stop);</span><br><span class="line">输出结果：</span><br><span class="line">2   //改结果为匹配到 10，然后将 10作为一个二进制数，然后再转化为十进制输出</span><br><span class="line">379cend$3</span><br></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char buffer[20]=&quot;10379cend$3&quot;;</span><br><span class="line">char *stop;</span><br><span class="line">printf(&quot;%d\n&quot;,strtol(buffer, &amp;stop, 8));</span><br><span class="line">printf(&quot;%s\n&quot;, stop);</span><br><span class="line">输出结果：</span><br><span class="line">543     //改结果为匹配到 1037，然后将1037 作为一个八进制数，然后再转化为十进制输出</span><br><span class="line">9cend$3</span><br></pre></td></tr></table></figure><p>上面匹配到1037, 7 + 3 <em> 8 + 1 </em> 8 <em> 8 </em> 8 = 543</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char buffer[20]=&quot;10379cend$3&quot;;</span><br><span class="line">char *stop;</span><br><span class="line">printf(&quot;%d\n&quot;,strtol(buffer, &amp;stop, 10));</span><br><span class="line">printf(&quot;%s\n&quot;, stop);</span><br><span class="line">输出结果：</span><br><span class="line">10379</span><br><span class="line">cend$3</span><br></pre></td></tr></table></figure><p>另外，如果base为0，且字符串不是以0x(或者0X)开头，则按十进制进行转化。</p><p>如果base为0或者16，并且字符串以0x（或者0X）开头，那么，x（或者X）被忽略，字符串按16进制转化。</p><p>如果base不等于0和16，并且字符串以0x(或者0X)开头，那么x被视为非法字符。</p><p>例如:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char buffer[20]=&quot;0x31da6c&quot;;</span><br><span class="line">char *stop;</span><br><span class="line">printf(&quot;%d\n&quot;,strtol(buffer, &amp;stop, 0));</span><br><span class="line">printf(&quot;%s\n&quot;, stop);</span><br><span class="line">输出结果(stop为空)：</span><br><span class="line">3267180</span><br></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char buffer[20]=&quot;0x31da6c&quot;;</span><br><span class="line">char *stop;</span><br><span class="line">printf(&quot;%d\n&quot;,strtol(buffer, &amp;stop, 13));</span><br><span class="line">printf(&quot;%s\n&quot;, stop);</span><br><span class="line">输出结果：</span><br><span class="line">0</span><br><span class="line">0x31da6c</span><br></pre></td></tr></table></figure><h3 id="memchr"><a href="#memchr" class="headerlink" title="memchr"></a>memchr</h3><p>void <em>memchr(const void </em>str, int c, size_t n)</p><p>在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char *p;</span><br><span class="line"></span><br><span class="line">if (len &lt; 0) &#123;</span><br><span class="line">    len = strlen(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = memchr(string, c, len);</span><br><span class="line"></span><br><span class="line">if (p) &#123;</span><br><span class="line">    return (p - string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return -1;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++ 通用方法</title>
      <link href="/2019/04/25/util/"/>
      <url>/2019/04/25/util/</url>
      
        <content type="html"><![CDATA[<p>该篇文章收录了自己所看到的一些优秀的通用方法，在以后的工作学习中作为参考。</p><a id="more"></a><h3 id="hex2int"><a href="#hex2int" class="headerlink" title="hex2int"></a>hex2int</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int hex2int(char *hex, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int res = 0;</span><br><span class="line">    char c;</span><br><span class="line"></span><br><span class="line">    while ((c = *hex++) &amp;&amp; i &lt; len) &#123;</span><br><span class="line">        res *= 0x10;    // res *= 16;?</span><br><span class="line"></span><br><span class="line">        if (c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;f&apos;) &#123;</span><br><span class="line">            res += (c - 0x57);  // res += (c - 87);?</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;F&apos;) &#123;</span><br><span class="line">            res += (c - 0x37);  // res += (c - 55);?</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123;</span><br><span class="line">            res += (c - 0x30);  // res += (c - 48);?</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (res &lt; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="url-decode"><a href="#url-decode" class="headerlink" title="url_decode"></a>url_decode</h3><p>url中可能包含一些ASCII编码的字符串例如’%20’等，该方法将这些编码转化成对应的字符，然后返回一个新的字符串</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">char *url_decode(char* url)</span><br><span class="line">&#123;</span><br><span class="line">    int i, hex_result;</span><br><span class="line">    int buf_idx = 0;</span><br><span class="line">    char *buf;</span><br><span class="line">    char hex[3];</span><br><span class="line">    int len = strlen(url);</span><br><span class="line"></span><br><span class="line">    if ((i = (memchr(url, &apos;%&apos;, len) - url)) &lt; 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf = mk_mem_malloc_z(len);</span><br><span class="line"></span><br><span class="line">    if (i &gt; 0) &#123;</span><br><span class="line">        strncpy(buf, url, i);</span><br><span class="line">        buf_idx = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (i &lt; len) &#123;</span><br><span class="line">        if (url[i] == &apos;%&apos; &amp;&amp; i + 2 &lt; len) &#123;</span><br><span class="line">            memset(hex, &apos;\0&apos;, sizeof(hex));</span><br><span class="line">            strncpy(hex, url + i + 1, 2);</span><br><span class="line">            hex[2] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">            hex_result = mk_utils_hex2int(hex, 2);</span><br><span class="line"></span><br><span class="line">            if (hex_result != -1) &#123;</span><br><span class="line">                buf[buf_idx] = hex_result;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                mk_mem_free(buf);</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            buf[buf_idx] = url[i];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        buf_idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[buf_idx] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">    return buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux 网络编程</title>
      <link href="/2019/04/25/linux_socket/"/>
      <url>/2019/04/25/linux_socket/</url>
      
        <content type="html"><![CDATA[<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>Socket编程中，TCP_NODELAY选项是用来控制是否开启Nagle算法，该算法是为了提高较慢的广域网传输效率，减小小分组的报文个数，完整描述：</p><a id="more"></a><blockquote><p>该算法要求一个TCP连接上最多只能有一个未被确认的小分组，在该小分组的确认到来之前，不能发送其他小分组。</p></blockquote><p>这里的小分组指的是报文长度小于MSS(Max Segment Size)长度的分组（MSS是在TCP握手的时候在报文选项里面进行通告的大小，主要是用来限制另一端发送数据的长度，防止IP数据包被分段，提高效率，一般是链路层的传输最大传输单元大小减去IP首部与TCP首部大小）。</p><p>如果小分组的确认ACK一直没有回来，那么就可能会触发TCP超时重传的定时器。</p><p>下面是一个简单的示意图，开启了Nagle算法与没有开启：</p><p><img src="https://github.com/liuyangshuo/liuyangshuo.github.io/raw/master/img/Nagle.jpg" alt="Nagle算法"></p><h3 id="getsockopt和setsockopt"><a href="#getsockopt和setsockopt" class="headerlink" title="getsockopt和setsockopt"></a>getsockopt和setsockopt</h3><p>&lt;sys/types.h&gt;</p><p>&lt;sys/socket.h&gt;</p><p>int getsockopt(int sock, int level, int optname, void <em>optval, socklen_t </em>optlen);</p><p>int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen);</p><p>获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时，选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。</p><h5 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h5><p>sock：将要被设置或者获取选项的套接字。</p><p>level：选项所在的协议层。</p><p>optname：需要访问的选项名。</p><p>optval：对于getsockopt()，指向返回选项值的缓冲。对于setsockopt()，指向包含新选项值的缓冲。</p><p>optlen：对于getsockopt()，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于setsockopt()，现选项的长度。</p><h5 id="optname取值："><a href="#optname取值：" class="headerlink" title="optname取值："></a>optname取值：</h5><blockquote><p>SO_DEBUG，打开或关闭调试信息  </p></blockquote><p>当optval不等于0时，打开调试信息，否则，关闭调试信息。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置 SOCK_DBG(第10)位，或清SOCK_DBG位。</p><blockquote><p>SO_REUSEADDR，打开或关闭地址复用功能</p></blockquote><p>当optval不等于0时，打开，否则，关闭。它实际所做的工作是置sock-&gt;sk-&gt;sk_reuse为1或0。</p><blockquote><p>SO_DONTROUTE，打开或关闭路由查找功能</p></blockquote><p>当optval不等于0时，打开，否则，关闭。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置或清SOCK_LOCALROUTE位。</p><blockquote><p>SO_BROADCAST，允许或禁止发送广播数据</p></blockquote><p>当optval不等于0时，允许，否则，禁止。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置或清SOCK_BROADCAST位。</p><blockquote><p>SO_SNDBUF，设置发送缓冲区的大小</p></blockquote><p>发送缓冲区的大小是有上下限的，其上限为256 <em> (sizeof(struct sk_buff) + 256)，下限为2048字节。该操作将sock-&gt;sk-&gt;sk_sndbuf设置为val </em> 2，之所以要乘以2，是防<br>止大数据量的发送，突然导致缓冲区溢出。最后，该操作完成后，因为对发送缓冲的大小 作了改变，要检查sleep队列，如果有进程正在等待写，将它们唤醒。</p><blockquote><p>SO_RCVBUF，设置接收缓冲区的大小</p></blockquote><p>接收缓冲区大小的上下限分别是：256 <em> (sizeof(struct sk_buff) + 256)和256字节。该操作将sock-&gt;sk-&gt;sk_rcvbuf设置为val </em> 2。</p><blockquote><p>SO_KEEPALIVE，套接字保持活跃</p></blockquote><p>如果协议是TCP，并且当前的套接字状态不是侦听(listen)或关闭(close)，那么，当optval不是零时，启用TCP保活定时 器，否则关闭保活定时器。对于所有协议，该操<br>作都会根据optval置或清 sock-&gt;sk-&gt;sk_flag中的 SOCK_KEEPOPEN位。</p><blockquote><p>SO_OOBINLINE，紧急数据放入普通数据流</p></blockquote><p>该操作根据optval的值置或清sock-&gt;sk-&gt;sk_flag中的SOCK_URGINLINE位。</p><blockquote><p>SO_NO_CHECK，打开或关闭校验和</p></blockquote><p>该操作根据optval的值，设置sock-&gt;sk-&gt;sk_no_check。</p><blockquote><p>SO_PRIORITY，设置在套接字发送的所有包的协议定义优先权。Linux通过这一值来排列网络队列</p></blockquote><p>这个值在0到6之间（包括0和6），由optval指定。赋给sock-&gt;sk-&gt;sk_priority。</p><blockquote><p>SO_LINGER，如果选择此选项, close或 shutdown将等到所有套接字里排队的消息成功发送或到达延迟时间后&gt;才会返回. 否则, 调用将立即返回</p></blockquote><p>该选项的参数（optval)是一个linger结构：</p><pre><code>struct linger {    int   l_onoff;       int   l_linger;  };</code></pre><p>如果linger.l_onoff值为0(关闭），则清 sock-&gt;sk-&gt;sk_flag中的SOCK_LINGER位；否则，置该位，并赋sk-&gt;sk_lingertime值为 linger.l_linger。</p><blockquote><p>O_PASSCRED，允许或禁止SCM_CREDENTIALS 控制消息的接收</p></blockquote><p>该选项根据optval的值，清或置sock-&gt;sk-&gt;sk_flag中的SOCK_PASSCRED位。</p><blockquote><p>SO_TIMESTAMP，打开或关闭数据报中的时间戳接收</p></blockquote><p>该选项根据optval的值，清或置sock-&gt;sk-&gt;sk_flag中的SOCK_RCVTSTAMP位，如果打开，则还需设sock-&gt;sk-&gt;sk_flag中的SOCK_TIMESTAMP位，同时，将全局变量<br>netstamp_needed加1。</p><blockquote><p>SO_RCVLOWAT，设置接收数据前的缓冲区内的最小字节数</p></blockquote><p>在Linux中，缓冲区内的最小字节数是固定的，为1。即将sock-&gt;sk-&gt;sk_rcvlowat固定赋值为1。</p><blockquote><p>SO_RCVTIMEO，设置接收超时时间</p></blockquote><p>该选项最终将接收超时时间赋给sock-&gt;sk-&gt;sk_rcvtimeo。</p><blockquote><p>SO_SNDTIMEO，设置发送超时时间</p></blockquote><p>该选项最终将发送超时时间赋给sock-&gt;sk-&gt;sk_sndtimeo。</p><blockquote><p>SO_BINDTODEVICE，将套接字绑定到一个特定的设备上</p></blockquote><p>该选项最终将设备赋给sock-&gt;sk-&gt;sk_bound_dev_if。</p><blockquote><p>SO_ATTACH_FILTER和SO_DETACH_FILTER</p></blockquote><p>关于数据包过滤，它们最终会影响sk-&gt;sk_filter。</p><h3 id="TCP-DEFER-ACCEPT"><a href="#TCP-DEFER-ACCEPT" class="headerlink" title="TCP_DEFER_ACCEPT"></a>TCP_DEFER_ACCEPT</h3><blockquote><p>setsockopt(int sockfd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &amp;timeout, sizeof(int))</p></blockquote><p>client发送ACK之后，server被唤醒，并试图读取数据，但是这个时候client还没有发送数据，server就会处于阻塞状态，浪费系统资源。</p><p>如果server端忽略client发送的ACK，而是直接等待接收到数据再唤醒，server醒来之后就可以直接处理数据，这就是TCP_DEFER_ACCEPT的作用。</p><p>如果client端设置TCP_DEFER_ACCEPT选项，client就会不发送ACK，而是直接发送数据给server端。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux 系统函数</title>
      <link href="/2019/04/24/linux_system_function/"/>
      <url>/2019/04/24/linux_system_function/</url>
      
        <content type="html"><![CDATA[<h3 id="线程数据共享"><a href="#线程数据共享" class="headerlink" title="线程数据共享"></a>线程数据共享</h3><p>pthread_getpecific和pthread_setspecific提供了在同一个线程中不同函数间共享数据即线程存储的一种方法。具体用法为：</p><hr><p>1.调用pthread_key_create()来创建一个类型为pthread_key_t类型的变量</p><p>该函数有两个参数，第一个参数就是声明的pthread_key_t变量，第二个参数是一个清理函数，用来在线程释放该线程存储的时候被调用。该函数指针可以设成NULL，这样系统将调用默认的清理函数。</p><p>2.调用pthread_setspcific()</p><p>当线程中需要存储特殊值的时候调用该函数，该函数有两个参数，第一个为前面声明的pthread_key_t变量，第二个为void*变量，用来存储任何类型的值。</p><p>3.如果需要取出所存储的值，调用pthread_getspecific()</p><p>该函数的参数为前面提到的pthread_key_t变量，该函数返回void*类型的值。</p><hr><a id="more"></a><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">pthread_key_t p_key;</span><br><span class="line"> </span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">    int *tmp = (int*)pthread_getspecific(p_key);//同一线程内的各个函数间共享数据。</span><br><span class="line">    printf(&quot;%d is runing in %s\n&quot;,*tmp,__func__);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">void *thread_func(void *args)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    pthread_setspecific(p_key,args);</span><br><span class="line"> </span><br><span class="line">    int *tmp = (int*)pthread_getspecific(p_key);//获得线程的私有空间</span><br><span class="line">    printf(&quot;%d is runing in %s\n&quot;,*tmp,__func__);</span><br><span class="line"> </span><br><span class="line">    *tmp = (*tmp)*100;//修改私有变量的值</span><br><span class="line"> </span><br><span class="line">    func1();</span><br><span class="line"> </span><br><span class="line">    return (void*)0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t pa, pb;</span><br><span class="line">    int a=1;</span><br><span class="line">    int b=2;</span><br><span class="line">    pthread_key_create(&amp;p_key,NULL);</span><br><span class="line">    pthread_create(&amp;pa, NULL,thread_func,&amp;a);</span><br><span class="line">    pthread_create(&amp;pb, NULL,thread_func,&amp;b);</span><br><span class="line">    pthread_join(pa, NULL);</span><br><span class="line">    pthread_join(pb, NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gettid-和pthread-self"><a href="#gettid-和pthread-self" class="headerlink" title="gettid()和pthread_self()"></a>gettid()和pthread_self()</h3><hr><ul><li>有两个不同的线程id,因为线程是由两部分组成：内核的线程支持+用户态的库支持(glibc)。</li><li>在linux环境中进程和线程没有什么区别，所有东西都是内核任务结构中的一个线程，并且每个线程都有自己的数字标识符：pid，类型为：pid_t，可由getpid()获得。</li><li>linux下的由glibc线程库实现的POSIX线程也有一个id，配型为：pthread_t，可由pthread_self()获得，其在内核看来也是一个轻量级进程(LWP)。</li><li>gittid()是内核给线程(轻量级进程)分配的id，类型也是pid_t，全局(所有进程中)唯一；pthread_self()是在用户态实现的，获取的id实际上是主线程分配给子线程的线程描述符的地址而已，只是在当前进程空间中唯一；</li><li>gettid()封装了syscall(__NR_gettid)。从gettid()和getpid()获取的都是内核所分配的id。这由它们的返回类型也可以看出来。getpid()获取的是进程id,gettid()获取的是线程id，不过它们本质上是一样的。</li></ul><hr><h3 id="进程控制函数prctl"><a href="#进程控制函数prctl" class="headerlink" title="进程控制函数prctl()"></a>进程控制函数prctl()</h3><p>int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5)</p><p>这是一个系统调用指令，是为进程制定而设计的，明确的选择取决于option:</p><blockquote><p>PR_GET_PDEATHSIG :返回处理器信号；</p><p>PR_SET_PDEATHSIG :arg2作为处理器信号pdeath被输入，正如其名，如果父进程不能再用，进程接受这个信号。</p><p>PR_GET_DUMPABLE :返回处理器标志dumpable;</p><p>PR_SET_DUMPABLE :arg2作为处理器标志dumpable被输入。</p><p>PR_GET_NAME :返回调用进程的进程名字给参数arg2; （Since Linux2.6.9）</p><p>PR_SET_NAME :把参数arg2作为调用进程的经常名字。（SinceLinux 2.6.11）</p><p>PR_GET_TIMING :</p><p>PR_SET_TIMING :判定和修改进程计时模式,用于启用传统进程计时模式的</p><p>PR_TIMING_STATISTICAL，或用于启用基于时间戳的进程计时模式的</p><p>PR_TIMING_TIMESTAMP。</p></blockquote><h3 id="sigaction信号检查和修改"><a href="#sigaction信号检查和修改" class="headerlink" title="sigaction信号检查和修改"></a>sigaction信号检查和修改</h3><p>int sigaction(int signo, const struct sigaction <em>restrict act, struct sigaction </em>restrict oact);</p><p>给信号signo设置新的信号处理函数，同事保留该信号原有的信号处理函数oact。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line">    void (*sa_handler)(int);</span><br><span class="line">    void (*sa_sigaction)(int, siginfo_t*, void *);</span><br><span class="line">    sigset_t sa_mask;</span><br><span class="line">    int sa_flags;</span><br><span class="line">    void (*sa_restorer)(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>sa_handler字段包含一个信号捕捉函数的地址</p></li><li><p>sa_sigaction字段包含一个信号捕捉函数的地址，需要为sa_flags设置SA_SIGINFO标志</p></li><li><p>sa_mask字段说明了一个信号集，在调用该信号捕捉函数之前，这一信号集要加进进程的信号屏蔽字中。仅当从信号捕捉函数返回时再将进程的信号屏蔽字复位为原先值。</p></li><li><p>sa_flag是一个选项，主要理解两个</p><ul><li><p>SA_NODEFER:  当信号处理函数正在进行时，不堵塞对于信号处理函数自身信号功能。</p></li><li><p>SA_RESETHAND:当用户注册的信号处理函数被执行过一次后，该信号的处理函数被设为系统默认的处理函数。</p></li><li><p>SA_SIGINFO 提供附加信息，一个指向siginfo结构的指针以及一个指向进程上下文标识符的指针，该选项设置之后就需要使用sa_sigaction取代sa_handler来指向一个函数</p></li></ul></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void signal_init()</span><br><span class="line">&#123;</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    memset(&amp;act, 0x0, sizeof(act));</span><br><span class="line">    </span><br><span class="line">    /* allow signals to be handled concurrently */</span><br><span class="line">    act.sa_flags = SA_SIGINFO | SA_NODEFER;</span><br><span class="line">    act.sa_sigaction = &amp;mk_signal_handler; //设置新的信号处理函数</span><br><span class="line"></span><br><span class="line">    sigaction(SIGSEGV, &amp;act, NULL);</span><br><span class="line">    sigaction(SIGBUS,  &amp;act, NULL);</span><br><span class="line">    sigaction(SIGHUP,  &amp;act, NULL);</span><br><span class="line">    sigaction(SIGINT,  &amp;act, NULL);</span><br><span class="line">    sigaction(SIGTERM, &amp;act, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>typedef void (*sighandler_t)(int);</p><p>sighandler_t signal(int signum, sighandler_t handler);</p><blockquote><p>signum : 我们要进行处理的信号。</p></blockquote><p>系统的信号我们可以再终端键入 kill -l查看(共64个)。其实这些信号时系统定义的宏。</p><blockquote><p>handler : 我们处理的方式（是系统默认还是忽略还是捕获）</p></blockquote><p>一般有3中方式进行操作。</p><hr><ol><li>signal(SIGINT, SIG_IGN);</li></ol><p>SIG_IGN代表忽略SIGINT信号，SIGINT信号代表由InterruptKey产生，通常是CTRL + C 或者是 DELETE,发送给所有ForeGround Group的进程。</p><p>下面我们写个死循环：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include</span><br><span class="line">#include</span><br><span class="line">int main(int argc , char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">signal(SIGINT,SIG_IGN);</span><br><span class="line">for(;;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们保存执行。按下CTRL _C程序没有反应。这就对了如果我们想结束该程序可以按下CTRL +\来结束其实当我们按下CTRL +\组合键时，是产生了SIGQUIT信号</p><ol start="2"><li>signal(SIGINT, SIG_DFL);</li></ol><p>SIGINT信号代表由InterruptKey产生，通常是CTRL + C 或者是 DELETE，发送给所有 ForeGroundGroup 的进程。SIG_DFL代表执行系统默认操作，其实对于大多数信号的系统默认动作时终止该进程。这与不写此处理函数是一样的。</p><p>我们将上面的程序改成:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include</span><br><span class="line">#include</span><br><span class="line">int main(int argc , char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//signal(SIGINT,SIG_IGN);</span><br><span class="line">signal(SIGINT,SIG_DFL)</span><br><span class="line">for(;;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时就可以按下CTRL +C 来终止该进程了把 signal(SIGINT,SIG_DFL);这句去掉，效果是一样的。</p><hr>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>创建守护进程</title>
      <link href="/2019/04/23/create_daemon/"/>
      <url>/2019/04/23/create_daemon/</url>
      
        <content type="html"><![CDATA[<h3 id="守护进程概述"><a href="#守护进程概述" class="headerlink" title="守护进程概述"></a>守护进程概述</h3><hr><ul><li>守护进程(daemon)是linux中的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</li><li>守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。</li><li>一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。</li><li>守护进程的名称通常以d结尾，比如sshd、xinetd、crond等。</li></ul><hr><a id="more"></a><h3 id="创建守护进程步骤"><a href="#创建守护进程步骤" class="headerlink" title="创建守护进程步骤"></a>创建守护进程步骤</h3><p>首先我们要了解一些基本概念：</p><h5 id="进程组："><a href="#进程组：" class="headerlink" title="进程组："></a>进程组：</h5><hr><ul><li>每个进程也属于一个进程组</li><li>每个进程主都有一个进程组号，该号等于该进程组组长的PID号</li><li>一个进程只能为它自己或子进程设置进程组ID号</li></ul><hr><h5 id="会话期："><a href="#会话期：" class="headerlink" title="会话期："></a>会话期：</h5><p>会话期(session)是一个或多个进程组的集合</p><p>setsid()函数可以建立一个对话期</p><p>如果，调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期</p><hr><ol><li>此进程变成该对话期的首进程</li><li>此进程变成一个新进程组的组长进程</li><li>此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误</li><li>为了保证这一点，我们先调用fork()然后exit()，此时只有子进程在运行</li></ol><hr><h5 id="编写守护进程的一般步骤步骤："><a href="#编写守护进程的一般步骤步骤：" class="headerlink" title="编写守护进程的一般步骤步骤："></a>编写守护进程的一般步骤步骤：</h5><hr><ol><li>在父进程中执行fork并exit退出</li><li>在子进程中调用setsid函数创建新的会话</li><li>在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录</li><li>在子进程中调用umask函数，设置进程的umask为0</li><li>在子进程中关闭任何不需要的文件描述符</li></ol><hr><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><ol><li>在后台运行。</li></ol><p>为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行</p><p>if(pid=fork()) </p><p>exit(0);//是父进程，结束父进程，子进程继续 </p><ol start="2"><li>脱离控制终端，登录会话和进程组 </li></ol><p>有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。</p><p>控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长：</p><p>setsid(); </p><p>说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。</p><ol start="3"><li>禁止进程重新打开控制终端</li></ol><p>现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端：</p><p>if(pid=fork()) </p><p>exit(0);//结束第一子进程，第二子进程继续（第二子进程不再是会话组长） </p><ol start="4"><li>关闭打开的文件描述符 </li></ol><p>进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按如下方法关闭它们： </p><p>for(i=0;i 关闭打开的文件描述符close(i);&gt; </p><ol start="5"><li>改变当前工作目录 </li></ol><p>进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如/tmpchdir(“/“) </p><ol start="6"><li>重设文件创建掩模 </li></ol><p>进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0); </p><ol start="7"><li>处理SIGCHLD信号</li></ol><p>处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。</p><p>signal(SIGCHLD,SIG_IGN); </p><p>这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才能释放僵尸进程。</p><p>deamon进程的标准实行，关闭了标准输入输出后，重新打开了/dev/null,就是黑洞，然后dup（0），dup（0）,相当于将fd=0,1,2,都指向了黑洞</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid;</span><br><span class="line">if ((pid = fork()) &lt; 0)&#123;</span><br><span class="line">    perror(&quot;Error: Failed creating to switch to daemon mode(fork failed)&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (pid &gt; 0)   /* parent */</span><br><span class="line">    exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">/* set files mask */</span><br><span class="line">umask(0);</span><br><span class="line"></span><br><span class="line">/* Create new session */</span><br><span class="line">setsid();</span><br><span class="line"></span><br><span class="line">if (chdir(&quot;/&quot;) &lt; 0) &#123;</span><br><span class="line">    perror(&quot;Error: Unable to unmount the inherited filesystem in the daemon process&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(stderr);</span><br><span class="line">fclose(stdout);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> daemon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++学习笔记</title>
      <link href="/2018/12/20/C++/"/>
      <url>/2018/12/20/C++/</url>
      
        <content type="html"><![CDATA[<p>这篇文章记录学习C++过程中的一些知识点。<br><a id="more"></a></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>我们用一段vector源码来看一下模板的使用。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class Alloc = alloc&gt;</span><br><span class="line">class vector&#123;</span><br><span class="line">public:</span><br><span class="line">    //vector 的嵌套型别定义</span><br><span class="line">    typedef T           value_type;</span><br><span class="line">    typedef value_type* pointer;</span><br><span class="line">    typedef value_type* iterator;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面用一个vector模板类来说明模板的使用。这样定义vector的好处就是可以在使用时确定里面存储的数据类型。vector<int>等等<br>同样我们也可以将自己定义的类按照这种形式来实现。<br>这个例子主要是介绍如何定义一个模板类以及使用。</int></p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>同样我们使用一段代码来说明<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __UTIL_H__</span><br><span class="line">#define __UTIL_H__</span><br><span class="line">... //代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>从上面的代码可以看出我们是在util.h文件中，虽然这个宏的名字可以随便起，而且在后面编写代码时也用不到，但是我们未避免宏重复定义而是用一定的格式(也可以：#ifndef __UTIL__)。</p><p>#ifndef __UTIL_H__,#define __UTIL_H__出现在文件的前两行， #endif放在文件的末尾。当第一次编译文件时，由于没有定义__UTIL_H__(保证其他地方不会定义)，就会进入该条件里面的代码，首先定义一下__UTIL_H__然后编译文件中的代码。当第二次进入该文件时，由于定义过__UTIL_H__，就会直接结束条件而不会编译中间的代码，从而保证代码不会重复编译。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Emscripten IndexedDB</title>
      <link href="/2018/12/12/IndexedDB/"/>
      <url>/2018/12/12/IndexedDB/</url>
      
        <content type="html"><![CDATA[<p>这篇文件介绍两种操作IndexedDB的方式，一种是通过Emscripten文件系统层提供的IndexedDb方法；另一种是通过fetch来存储网络服务器中的文件或内存文件。第一种方式适用于存储小型数据，第二种方式适用于存储大型文件。</p><h2 id="Emscripten异步IndexedDB-API"><a href="#Emscripten异步IndexedDB-API" class="headerlink" title="Emscripten异步IndexedDB API"></a>Emscripten异步IndexedDB API</h2><p>IndexedDB是一个允许您持久存储数据的浏览器API，也就是说，您可以将数据保存在那里，然后在用户重新访问网页时加载数据。IDBFS通过Emscripten文件系统层提供了一种使用IndexedDB的方法。emscripten_idb_*此处列出的方法提供了一个直接指向IndexedDB的替代API，从而避免了文件系统层的开销。<br><a id="more"></a><br>下面通过一个简单示例来演示数据的基本操作：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;emscripten.h&gt;</span><br><span class="line"></span><br><span class="line">#define DB &quot;THE_DB&quot;</span><br><span class="line">#define STAGE 0</span><br><span class="line"></span><br><span class="line">int expected;</span><br><span class="line">int result;</span><br><span class="line"></span><br><span class="line">void ok(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;arg = %d\n&quot;, (int)arg;</span><br><span class="line">    printf(&quot;expected = %d\n&quot;, expected);</span><br><span class="line">    assert(expected == (int)arg);</span><br><span class="line">    //REPORT_RESULT(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onerror(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    assert(expected == (int)arg);</span><br><span class="line">    //REPORT_RESULT(999);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onload(void* arg, void* ptr, int num)</span><br><span class="line">&#123;</span><br><span class="line">    assert(expected == (int)arg);</span><br><span class="line">    printf(&quot;loaded %s\n&quot;, ptr);</span><br><span class="line">    assert(num == strlen(SECRET)+1);</span><br><span class="line">    assert(strcmp(ptr, SECRET) == 0);</span><br><span class="line">    //REPORT_RESULT(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onbadload(void* arg, void* ptr, int num)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;load failed, surprising\n&quot;);</span><br><span class="line">    //REPORT_RESULT(999);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void oncheck(void* arg, int exists)</span><br><span class="line">&#123;</span><br><span class="line">    assert(expected == (int)arg);</span><br><span class="line">    printf(&quot;exists? %d\n&quot;, exists);</span><br><span class="line">    assert(exists);</span><br><span class="line">    //REPORT_RESULT(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onchecknope(void* arg, int exists)</span><br><span class="line">&#123;</span><br><span class="line">    assert(expeted == (int)arg);</span><br><span class="line">    printf(&quot;exists (hopefully not)? %d\n&quot;, exists);</span><br><span class="line">    assert(!exists);</span><br><span class="line">    //REPORT_RESULT(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line">  result = STAGE;</span><br><span class="line">#if STAGE == 0</span><br><span class="line">  expected = 12;</span><br><span class="line">  emscripten_idb_async_store(DB, &quot;the_secret&quot;, SECRET, strlen(SECRET)+1, (void*)expected, ok, onerror);</span><br><span class="line">  printf(&quot;storing %s\n&quot;, SECRET);</span><br><span class="line">#elif STAGE == 1</span><br><span class="line">  expected = 12;</span><br><span class="line">  emscripten_idb_async_load(DB, &quot;the_secret&quot;, (void*)expected, onload, onerror);</span><br><span class="line">//  printf(&quot;onload %d\n&quot;, (int)onload);</span><br><span class="line">#elif STAGE == 2</span><br><span class="line">  expected = 44;</span><br><span class="line">  emscripten_idb_async_delete(DB, &quot;the_secret&quot;, (void*)expected, ok, onerror);</span><br><span class="line">  printf(&quot;deleting the_secret\n&quot;);</span><br><span class="line">#elif STAGE == 3</span><br><span class="line">  expected = 55;</span><br><span class="line">  emscripten_idb_async_load(DB, &quot;the_secret&quot;, (void*)expected, onbadload, ok);</span><br><span class="line">  printf(&quot;loading, should fail as we deleted\n&quot;);</span><br><span class="line">#elif STAGE == 4</span><br><span class="line">  expected = 66;</span><br><span class="line">  emscripten_idb_async_exists(DB, &quot;the_secret&quot;, (void*)expected, oncheck, onerror);</span><br><span class="line">#elif STAGE == 5</span><br><span class="line">  expected = 77;</span><br><span class="line">  emscripten_idb_async_exists(DB, &quot;the_secret&quot;, (void*)expected, onchecknope, onerror);</span><br><span class="line">#else</span><br><span class="line">  assert(0);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void never() &#123;</span><br><span class="line">  EM_ASM(&#123; alert(&apos;this should never be reached! runtime must not be shut down!&apos;) &#125;);</span><br><span class="line">  assert(0);</span><br><span class="line">  while (1) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  //atexit(never);</span><br><span class="line">  test();</span><br><span class="line">  emscripten_exit_with_live_runtime();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法说明：</p><blockquote><p>void emscritpen_idb_async_load(const cahr <em>db_name, const char </em>file_id, void* arg, em_async_wget_onload_func onload, em_arg_callback_func onerror)</p></blockquote><p>异步从本地IndexedDB存储加载数据。这允许持久数据，而不需要文件系统层的开销，当数据准备就绪时，onload函数会被调用，如果发生任何错误则onerror会被调用</p><p>参数：</p><ul><li>db_name：从哪个数据库加载数据</li><li>file_id:要加载的数据标识符</li><li>arg(void*):传递给回调的用户定义的数据，不受API本身的影响。这可以被回调用来标识相关的调用</li><li>onload(em_async_wget_onload_func):成功将URL加载到缓冲区时进行回调，回调方法参数：<ul><li>(void)*:等于arg(用户定义数据)</li><li>(void)*:指向带有数据的缓冲区指针</li><li>(int)：缓冲区大小，以字节为单位</li></ul></li><li>onerror(em_arg_callback_func):<ul><li>(void)*：等于arg(用户定义数据)</li></ul></li></ul><blockquote><p>void emscripten_idb_async_store(const char <em>db_name, const char </em>file_id, void<em> ptr, int num, void</em> arg, em_arg_callback_func onstore, em_arg_callback_func onerror)</p></blockquote><p>异步存储数据到本地IndexedDB。不需要文件系统层就可以将数据持久化。当数据存储存储时会调用onstore函数，如果发生错误就会调用onerror函数。</p><p>参数：</p><ul><li>ptr:指向存储数据的指针</li><li>num:存储的数据有多少字节</li><li>onstore(em_arg_callback_func):对数据缓冲区成功存储到URL的回调</li></ul><blockquote><p>void emscripten_idb_async_delete(const char <em>db_name, const char </em>file_id, void *arg, em_arg_callback_func ondelete, em_arg_callback_func onerror)</p></blockquote><p>从本地IndexedDB数据库异步删除数据。当数据被删除试调用ondelte函数，当发生错误是调用onerror函数。</p><p>参数：</p><ul><li>ondelete(em_arg_callback_func):成功删除的回调</li></ul><blockquote><p>void emscripten_idb_async_exists(const char <em>db_name, const char </em>file_id, void* arg, em_idb_exists_func oncheck, em_arg_callback_func onerror)</p></blockquote><p>异步检查本地IndexedDB数据库中是否存在特定ID的数据。当数据被选中是，则调用oncheck函数，如果发生错误就会调用onerror函数</p><p>参数：</p><ul><li>oncheck(em_idb_exists_func):成功检查的回调，回调函数参数：<ul><li>int:文件是否存在</li></ul></li></ul><blockquote><p>int emscripten_run_preload_plugins(const char* file, em_str_callback_func onload, em_str_callback_func onerror)</p></blockquote><p>异步地在文件上运行预加载插件。它工作在已经存在的文件数据上，并执行任何可用的作为预加载插件的所需的异步操作，例如解码图像以供在IMG_Load中使用的音频解码Mix_LoadWAV。操作完成后会调用onload函数，如果发生错误则调用onerror函数</p><p>参数：</p><ul><li>onload(em_str_callback_func):对文件的成功处理进行回调,回调函数参数：<ul><li>(const char)*:处理的文件</li></ul></li><li>onerror(em_str_callback_func):调用失败，回调函数参数：<ul><li>(const char)*:操作失败的文件</li></ul></li></ul><h2 id="通过Fetch-API操作IndexedDB"><a href="#通过Fetch-API操作IndexedDB" class="headerlink" title="通过Fetch API操作IndexedDB"></a>通过Fetch API操作IndexedDB</h2><h3 id="从网络文件持久化数据"><a href="#从网络文件持久化数据" class="headerlink" title="从网络文件持久化数据"></a>从网络文件持久化数据</h3><p>Emscripten FETCH API允许本机代码通过XHR(HTTPGET、PUT、POST)从远程服务器传输文件，并在浏览器的IndexedDB存储中本地宝存已下载的文件，以便在随后的页面访问是能够在本地重新访问这些文件。</p><blockquote><p>为了使用FETCH API，需要使用-s FETCH=1。</p></blockquote><p>下面的应用程序异步地将文件从Web服务器下载到应用程序堆中的内存和IndexedDB中。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;emscripten/fetch.h&gt;</span><br><span class="line"></span><br><span class="line">void downloadSucceeded(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;Finished downloading %llu bytes from URL %s.\n&quot;, fetch-&gt;numBytes, fetch-&gt;url);</span><br><span class="line">  // The data is now available at fetch-&gt;data[0] through fetch-&gt;data[fetch-&gt;numBytes-1];</span><br><span class="line">  emscripten_fetch_close(fetch); // Free data associated with the fetch.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void downloadFailed(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;Downloading %s failed, HTTP failure status code: %d.\n&quot;, fetch-&gt;url, fetch-&gt;status);</span><br><span class="line">  emscripten_fetch_close(fetch); // Also free data on failure.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  emscripten_fetch_attr_t attr;</span><br><span class="line">  emscripten_fetch_attr_init(&amp;attr);</span><br><span class="line">  strcpy(attr.requestMethod, &quot;GET&quot;);</span><br><span class="line">  attr.attributes = EMSCRIPTEN_FETCH_LOAD_TO_MEMORY | EMSCRIPTEN_FETCH_PERSIST_FILE;</span><br><span class="line">  attr.onsuccess = downloadSucceeded;</span><br><span class="line">  attr.onerror = downloadFailed;</span><br><span class="line">  emscripten_fetch(&amp;attr, &quot;myfile.dat&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果为调用Emscripten_FETCH指定了相对路径名，如上面的示例所示，则相对于当前页面的href(URL)执行XHR。传递完全限定的绝对URL允许跨域下载文件，但是这些文件必须符合http访问控制(CORS)规则.</p><p>默认情况下，FETCH API异步运行，这意味着Emscripten_FETCH()函数调用将立即返回，并且操作将继续发生在后台。操作完成后，将调用“成功”或“失败”回调。</p><p>FETCH API发出的XHR请求受制于通常的浏览器缓存行为。这些缓存是暂时性的(临时的)，因此无法保证数据将在给定的一段时间内持续在缓存中。此外，如果文件有点大(多兆字节)，浏览器通常根本不缓存下载。<br>为了支持保存下载文件的更显式控制，FETCH API与浏览器的IndexedDBAPI交互，后者可以加载和存储在以后访问页面时可用的大型数据文件。<br>如果应用程序希望下载一个文件以进行本地访问，但不需要立即使用该文件，例如，当预先为以后的访问预先加载数据时，最好完全避免使用Emscripten_FETCH_LOAD_TO_Memory标志，而只传递Emscripten_FETCH_REVERT_FILE_FILE标志。这将导致FETCH直接将文件下载到IndexedDB，从而避免在下载完成后暂时将文件填充到内存中。在这种情况下，onSuccess()处理程序将只报告下载的文件大小，而不会将数据字节包含到文件中。</p><h3 id="从内存中持久化数据"><a href="#从内存中持久化数据" class="headerlink" title="从内存中持久化数据"></a>从内存中持久化数据</h3><p>有时，从应用程序内存到IndexedDB(不需要执行任何XHR)的字节范围很有用。通过将特殊的HTTP动作动词“EM_IDB_STORE”传递给Emscripten提取操作，这在Emscripten FETCH API中是可能的。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void success(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;IDB store succeeded.\n&quot;);</span><br><span class="line">  emscripten_fetch_close(fetch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void failure(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;IDB store failed.\n&quot;);</span><br><span class="line">  emscripten_fetch_close(fetch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void persistFileToIndexedDB(const char *outputFilename, uint8_t *data, size_t numBytes) &#123;</span><br><span class="line">  emscripten_fetch_attr_t attr;</span><br><span class="line">  emscripten_fetch_attr_init(&amp;attr);</span><br><span class="line">  strcpy(attr.requestMethod, &quot;EM_IDB_STORE&quot;);</span><br><span class="line">  attr.attributes = EMSCRIPTEN_FETCH_REPLACE | EMSCRIPTEN_FETCH_PERSIST_FILE;</span><br><span class="line">  attr.requestData = (char *)data;</span><br><span class="line">  attr.requestDataSize = numBytes;</span><br><span class="line">  attr.onsuccess = success;</span><br><span class="line">  attr.onerror = failure;</span><br><span class="line">  emscripten_fetch(&amp;attr, outputFilename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  // Create data</span><br><span class="line">  uint8_t *data = (uint8_t*)malloc(10240);</span><br><span class="line">  srand(time(NULL));</span><br><span class="line">  for(int i = 0; i &lt; 10240; ++i) data[i] = (uint8_t)rand();</span><br><span class="line"></span><br><span class="line">  persistFileToIndexedDB(&quot;outputfile.dat&quot;, data, 10240);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从IndexedDB删除文件"><a href="#从IndexedDB删除文件" class="headerlink" title="从IndexedDB删除文件"></a>从IndexedDB删除文件</h3><p>可以使用HTTP动作动词“EM_IDB_DELETE”从IndexedDB清除文件：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void success(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;Deleting file from IDB succeeded.\n&quot;);</span><br><span class="line">  emscripten_fetch_close(fetch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void failure(emscripten_fetch_t *fetch) &#123;</span><br><span class="line">  printf(&quot;Deleting file from IDB failed.\n&quot;);</span><br><span class="line">  emscripten_fetch_close(fetch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  emscripten_fetch_attr_init(&amp;attr);</span><br><span class="line">  strcpy(attr.requestMethod, &quot;EM_IDB_DELETE&quot;);</span><br><span class="line">  emscripten_fetch(&amp;attr, &quot;filename_to_delete.dat&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> WebAssembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebAssembly </tag>
            
            <tag> Emscripten </tag>
            
            <tag> IndexedDB </tag>
            
            <tag> Fetch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Emscripten Embind</title>
      <link href="/2018/12/09/Embind/"/>
      <url>/2018/12/09/Embind/</url>
      
        <content type="html"><![CDATA[<p>Embind用于将C++函数和类绑定到javascript,这样编译的代码就可以通过javascript来调用<br>本文介绍如何使用EMSCRIPTEN_BINDINGS()块来为函数、类、值类型、指针（包括原始指针和智能指针）、枚举和常量创建绑定，以及如何为可以在javascript中重写的抽象类创建绑定。还简要解释了如何管理传递给javascript的C++对象句柄的内存</p><hr><a id="more"></a><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p>下面以一个简单的例子开始</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//quick_example.cpp</span><br><span class="line">#include &lt;emscripten/bind.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace emscripten;</span><br><span class="line"></span><br><span class="line">float lerp(float a, float b, float t) &#123;</span><br><span class="line">    return (1 - t) * a + t * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(my_module) &#123;</span><br><span class="line">    function(&quot;lerp&quot;, &amp;lerp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对以上代码进行编译，编译需要加–bind参数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc --bind -o quick_example.js quick_example.cpp</span><br></pre></td></tr></table></figure></p><p>编译之后就可以在javascript代码中调用上边的注册函数</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Module = &#123;</span><br><span class="line">    onRuntimeInitialized: function() &#123;</span><br><span class="line">        console.log(&apos;lerp result: &apos; + Module.lerp(1, 2, 0.5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;quick_example.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="类和内存管理"><a href="#类和内存管理" class="headerlink" title="类和内存管理"></a>类和内存管理</h3><p>向javascript公开类需要一个更复杂的绑定语句：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    MyClass(int x, std::string y): x(x), y(y) &#123;&#125;</span><br><span class="line">    void incrementX() &#123;</span><br><span class="line">        ++x;</span><br><span class="line">    &#125;</span><br><span class="line">    int getX() const &#123; return x;&#125;</span><br><span class="line">    void setX(int x_) &#123; x = x_; &#125;</span><br><span class="line">    static std::string getStringFromInstance(const MyClass&amp; instance) &#123;</span><br><span class="line">        return instance.y;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">    std::stirng y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//Binding code</span><br><span class="line">EMSCRIPTEN_BINDINGS(my_class_example) &#123;</span><br><span class="line">    class_&lt;MyClass&gt;(&quot;MyClass&quot;)</span><br><span class="line">    .constructor&lt;int, std::string&gt;() //构造函数</span><br><span class="line">    .function(&quot;incrementX&quot;, &amp;MyClass::incrementX) //非静态函数</span><br><span class="line">    .property(&quot;x&quot;, &amp;MyClass::getX, &amp;MyClass:setX)</span><br><span class="line">    .class_function(&quot;getStringFromInstance&quot;, &amp;MyClass:getStringFromInstance) //静态函数</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在javascript中使用：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var instance = new Module.MyClass(10, &quot;hello&quot;);</span><br><span class="line">instance.incrementX();</span><br><span class="line">instance.x; // 11</span><br><span class="line">instance.x = 20 // 20</span><br><span class="line">Module.MyClass.getStringFromInstance(instance); // &quot;hello&quot;</span><br><span class="line">instance.delete();</span><br></pre></td></tr></table></figure><p>由于Emscripten无法自动调用C++对象的析构函数，所以javascript代码必须显示删除他接收到的任何C++对象句柄，否则Emscripten堆将无限期地增长</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>基本类型的手动内存管理非常麻烦，因此Embind提供对值类型的支持。Value arrays转换为javascript数组和value objects转换为javascript对象</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct Point2f &#123;</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct PersonRecord &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PersonRecord findPersonAtLocation(Point2f);</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(my_value_example) &#123;</span><br><span class="line">    value_array&lt;Point2f&gt;(&quot;Point2f&quot;)</span><br><span class="line">        .element(&amp;Point2f::x)</span><br><span class="line">        .element(&amp;Point2f::y)</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">    value_object&lt;PersonRecord&gt;(&quot;PersonRecord&quot;)</span><br><span class="line">        .field(&quot;name&quot;, &amp;PersonRecord::name)</span><br><span class="line">        .field(&quot;age&quot;, &amp;PersonRecord::age)</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">    function(&quot;findPersonAtLocation&quot;, &amp;findPersonAtLocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式javascript就无需考虑对象的生命周期</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person = Module.findPersonAtLocation([10.2, 156.5]);</span><br><span class="line">console.log(&apos;Found someone! Their name is &apos; + person.name + &apos;and they are&apos; + person.age + &apos; years old&apos;);</span><br></pre></td></tr></table></figure><h3 id="高级类概念"><a href="#高级类概念" class="headerlink" title="高级类概念"></a>高级类概念</h3><h4 id="原始指针"><a href="#原始指针" class="headerlink" title="原始指针"></a>原始指针</h4><p>因为原始指针的语义不明确，embind需要将使用allow_raw_pointers标记：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;&#125;;</span><br><span class="line">C* passThrough(C* ptr) &#123; return ptr; &#125;</span><br><span class="line">EMSCRIPTEN_BINDINGS(raw_pointers) &#123;</span><br><span class="line">    class&gt;&lt;C&gt;(&quot;C&quot;);</span><br><span class="line">    function(&quot;passThrough&quot;, &amp;passThrough, allow_raw_pointers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部构造函数"><a href="#外部构造函数" class="headerlink" title="外部构造函数"></a>外部构造函数</h4><p>这里有两种方法来指定类的构造函数<br>一种是零参数模板形式，使用模板中指定的参数调用自然构造函数：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    MyClass(int, float);</span><br><span class="line">    void someFunction();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(external_constructors) &#123;</span><br><span class="line">    class_&lt;MyClass&gt;(&quot;MyClass&quot;)</span><br><span class="line">        .constructor&lt;int, float&gt;()</span><br><span class="line">        .function(&quot;someFunction&quot;, &amp;MyClass::someFunction)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种形式是接受函数指针参数，并用于使用工厂函数构造自身的类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    virtual void someFunction() = 0；</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass* makeMyClass(int, float); //Factory function</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(external_constructors) &#123;</span><br><span class="line">    class_&lt;MyClass&gt;(&quot;MyClass&quot;)</span><br><span class="line">        .constructor(&amp;makeMyClass, allow_raw_pointers())</span><br><span class="line">        .function(&quot;someFunction&quot;, &amp;MyClass::someFunction)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面两种形式作为接口在JavaScript中使用时是相同的：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var instance = new MyClass(10, 15.5);</span><br><span class="line">// instance is backed by a raw pointer to a MyClass in the Emscripten heap</span><br></pre></td></tr></table></figure><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>如果要使用智能指针来管理对象的生存周期，Embind必须指出智能指针的类型。<br>例如，考虑通过一个指向类C的智能指针std::shared_ptr<c>的生存周期，最好的方式是使用smart_ptr_constructor()来注册智能指针类型：</c></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(better_smart_pointers) &#123;</span><br><span class="line">    class_&lt;C&gt;(&quot;C&quot;)</span><br><span class="line">        .smart_ptr_constructor(&quot;C&quot;, &amp;std::make_shared&lt;C&gt;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个类型的一个对象被构造（如，new Module.C() ),就会返回一个智能指针std::shared_ptr<c>.<br>另一只形式是在EMSCRIPTEN_BINDINGS()中使用smart_ptr().</c></p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(smart_pointers) &#123;</span><br><span class="line">    class_&lt;C&gt;(&quot;C&quot;)</span><br><span class="line">        .constructor&lt;&gt;()</span><br><span class="line">        .smart_ptr&lt;std::shared_ptr&lt;C&gt;&gt;(&quot;C&quot;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该定义可以返回一个std::shared_ptr<c>。或者使用std::shared_ptr<c>作为参数，但是使用new Module.C()将会返回一个原始指针。</c></c></p><h5 id="唯一智能指针"><a href="#唯一智能指针" class="headerlink" title="唯一智能指针"></a>唯一智能指针</h5><p>同共享指针一样不过返回类型为std::unique_ptr。</p><h5 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h5><p>关于自定义智能指针模板，必须使用专门的smart_ptr_trait模板。</p><h4 id="JavaScript原型上的非成员函数"><a href="#JavaScript原型上的非成员函数" class="headerlink" title="JavaScript原型上的非成员函数"></a>JavaScript原型上的非成员函数</h4><p>JavaScript原型上的方法可以是非成员函数，主要实例句柄可以转换为非成员函数的第一个参数。典型的例子是当向JavaScript公开的函数与C++方法的行为不完全匹配时。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Array10 &#123;</span><br><span class="line">    int&amp; get(size_t index) &#123;</span><br><span class="line">        return data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    int data[10];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">val Array10_get(Array10&amp; arr, size_t index) &#123;</span><br><span class="line">    if (index &lt; 10) &#123;</span><br><span class="line">        return val(arr.get(index));</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">            return val::undefined();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(non_member_functions) &#123;</span><br><span class="line">    class_&lt;Array10&gt;(&quot;Array10&quot;)</span><br><span class="line">        .function(&quot;get&quot;, &amp;Array10_get)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在JavaScript中派生C-类"><a href="#在JavaScript中派生C-类" class="headerlink" title="在JavaScript中派生C++类"></a>在JavaScript中派生C++类</h4><p>如果C++类中有虚拟或抽象成员函数，则可以在JavaScript中重写他们。因为JavaScript没有C++虚函数表的信息，Embind需要一点胶水代码将C++虚函数调用转换为JavaScript调用。</p><h5 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h5><p>通过一个例子来说明，该方法必须通过JavaScript实现。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Interface &#123;</span><br><span class="line">    virtual void invoke(const std::string&amp; str) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct InterfaceWrapper : public wrapper&lt;Interface&gt; &#123;</span><br><span class="line">    EMSCRIPTEN_WRAPPER(InterfaceWrapper);</span><br><span class="line">    void invoke(const std::string&amp; str) &#123;</span><br><span class="line">        return call&lt;void&gt;(&quot;invoke&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(interface) &#123;</span><br><span class="line">    class_&lt;Interface&gt;(&quot;Interface&quot;)</span><br><span class="line">        .function(&quot;invoke&quot;, &amp;Interface::invoke, pure_virtual())</span><br><span class="line">        .allow_subclass&lt;InterfaceWrapper&gt;(&quot;InterfaceWrapper&quot;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allow_subclass()向接口绑定添加两个特殊方法：extend和implement。extend循序JavaScript在样式中子类。当有JavaScript对象时使用implement。并且希望使用它来实现C++接口。</p><h5 id="extend例子"><a href="#extend例子" class="headerlink" title="extend例子"></a>extend例子</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var DerivedClass = Module.Interface.extend(&quot;Interface&quot;, &#123;</span><br><span class="line">    // __construct and __destruct are optional. They are included</span><br><span class="line">    // in this example for illustration purposes.</span><br><span class="line">    // If you override __construct or __destruct, don&apos;t forget to </span><br><span class="line">    // call the parent implementation!</span><br><span class="line">    __construct : function() &#123;</span><br><span class="line">        this.__parent.__construct.call(this);</span><br><span class="line">    &#125;,</span><br><span class="line">    __destruct : function() &#123;</span><br><span class="line">        this.__parent.__destruct.call(this);</span><br><span class="line">    &#125;,</span><br><span class="line">    invoke : function() &#123;</span><br><span class="line">        // your code goes here</span><br><span class="line">    &#125;, </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var instance = new DerivedClass;</span><br></pre></td></tr></table></figure><h5 id="implement例子"><a href="#implement例子" class="headerlink" title="implement例子"></a>implement例子</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x &#123;</span><br><span class="line">    invoke : function(str) &#123;</span><br><span class="line">        console.log(&apos;invoking with: &apos; + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var interfaceObject = Module.Interface.implement(x);</span><br></pre></td></tr></table></figure><p>现在interfaceObject可以传递给任何接受Interface指针或引用。</p><h5 id="非抽象虚拟方法"><a href="#非抽象虚拟方法" class="headerlink" title="非抽象虚拟方法"></a>非抽象虚拟方法</h5><p>如果C++类具有非纯虚函数，则可以重写它，但不必重写。这需要一个稍微不同的包装器实现:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">    virtual void invoke(const std::string&amp; str) &#123;</span><br><span class="line">        //default implementation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct BaseWrapper : public Wrapper&lt;Base&gt; &#123;</span><br><span class="line">    EMSCRIPTEN_WRAPPER(BaseWrapper);</span><br><span class="line">    void invoke(const std::string&amp; str) &#123;</span><br><span class="line">        return call&lt;void&gt;(&quot;invoke&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(interface) &#123;</span><br><span class="line">    class_&lt;Base&gt;(&quot;Base&quot;)</span><br><span class="line">        .allow_subclass&lt;BaseWrapper&gt;(&quot;BaseWrapper&quot;)</span><br><span class="line">        .function(&quot;invoke&quot;, optional_override([](Base&amp; self, const std::)stirng&amp; str)&#123;</span><br><span class="line">            return self.Base::invoke(str);</span><br><span class="line">        &#125;))</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用JavaScript对象来实现Base时，invoke是可选择的。为了避免wrapper和JavaScript质检出现无线循环必须为invoke使用特殊的lambda绑定。</p><h5 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h5><p>基类绑定的定义如下：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(base_example) &#123;</span><br><span class="line">    class_&lt;BaseClass&gt;(&quot;BaseClass&quot;);</span><br><span class="line">    class_&lt;DerivedClass, base&lt;BaseClass&gt;&gt;(&quot;DerivedClass&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的任何BaseClass的成员函数可以访问DerivedClass的实例。此外，任何接受BaseClass实例的函数可以给一个DerivedClass的实例。</p><h5 id="自动向下传递"><a href="#自动向下传递" class="headerlink" title="自动向下传递"></a>自动向下传递</h5><p>如果C++类是多态的（也就是说，它有一个虚方法），那么Embind支持函数返回值的自动下传。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123; virtual ~ Base() &#125;; //the virtual makes Base and Derived Polymorphic</span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line">Base* getDerivedInstance() &#123;</span><br><span class="line">    return new Derived;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(automatic_downcasting) &#123;</span><br><span class="line">    class_&lt;Base&gt;(&quot;Base&quot;);</span><br><span class="line">    class_&lt;Derived， base&lt;Base&gt;&gt;(&quot;Derived&quot;);</span><br><span class="line">    function(&quot;getDerivedInstance&quot;, &amp;getDerivedInstance, allow_raw_pointers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JavaScript中调用Module.getDerivedInstance,返回Derived实例句柄，其中所有Derived方法是可用的。</p><h3 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h3><p>构造函数和普通函数可以在参数上重载，但是Enbind不支持基于类型的重载。指定重载是，使用select_overload()函数来选择适当的签名。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct HasOverloadedMethods &#123;</span><br><span class="line">    void foo();</span><br><span class="line">    void foo(int i);</span><br><span class="line">    void foo(float f) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(overloads) &#123;</span><br><span class="line">    class_&lt;HasOverloadedMethods&gt;(&quot;HasOverloadedMethods&quot;)</span><br><span class="line">        .function(&quot;foo&quot;, select_overload&lt;void()&gt;(&amp;HasOverloadedMethods::foo))</span><br><span class="line">        .function(&quot;foo_int&quot;, select_overload&lt;void(int)&gt;(&amp;HasOverloadedMethods::foo))</span><br><span class="line">        .function(&quot;foo_float&quot;, select_overload&lt;void(float)&gt;(&amp;HasOverloadMethods::foo))</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h3><p>直接通过例子来看一下enum是如何使用：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">enum OldStyle &#123;</span><br><span class="line">    OLD_STYLE_ONE,</span><br><span class="line">    OLD_STYLE_TWO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum class NewStyle &#123;</span><br><span class="line">    ONE,</span><br><span class="line">    TWO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(my_enum_example) &#123;</span><br><span class="line">    enum_&lt;OldStyle&gt;(&quot;OldStyle&quot;)</span><br><span class="line">        .value(&quot;ONE&quot;, OLD_STYLE_ONE)</span><br><span class="line">        .value(&quot;TWO&quot;, OLD_STYLE_TWO)</span><br><span class="line">        ;</span><br><span class="line">    enum_&lt;NewStyle&gt;(&quot;NewStyle&quot;)</span><br><span class="line">        .value(&quot;ONE&quot;, NewStyle::ONE)</span><br><span class="line">        .value(&quot;TWO&quot;, NewStyle::TWO)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个例子中，JavaScript都将枚举值作为类型的属性访问：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Module.OldStyle.ONE;</span><br><span class="line">Module.NewStyle.TWO;</span><br></pre></td></tr></table></figure><h3 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h3><p>JavaScript使用C++常数</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(my_constant_example) &#123;</span><br><span class="line">    constant(&quot;DOME_CONSTANT&quot;, SOME_CONSTANT);</span><br><span class="line">&#125;</span><br><span class="line">SOME_CONSTANT可以有任何已知的类型</span><br></pre></td></tr></table></figure><h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p>在某些情况下，将原始二进制直接公开给JavaScript代码作为类型化数组是很有价值的，这样就可以在不进行复制的情况下使用它。例如，这对于直接从堆上传大型WebGL纹理非常有用。<br>内存视图应该被视为原始指针；运行时不对生存期和有效性进行管理，而且如果修改或释放底层对象，则很容易损坏数据。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;emscripten/bind.h&gt;</span><br><span class="line">#include &lt;emscripten/val.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace emscripten;</span><br><span class="line"></span><br><span class="line">unsigned char *byteBuffer = /* ... */;</span><br><span class="line">size_t bufferLength = /* ... */;</span><br><span class="line"></span><br><span class="line">val getBytes() &#123;</span><br><span class="line">    return val(typed_memory_view(bufferLength, byteBuffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(memory_view_example) &#123;</span><br><span class="line">    function(&quot;getBytes&quot;, &amp;getBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用的JavaScript代码将在Emscripten堆中接受一个类型化数组视图：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myUint8Array = Module.getBytes()</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;POST&apos;, /* ... */);</span><br><span class="line">xhr.send(myUint8Array);</span><br></pre></td></tr></table></figure></p><p>类型化数组视图将具有适当的匹配类型，例如unsigned char 数组或指针。</p><h3 id="使用val将JavaScript转化为C"><a href="#使用val将JavaScript转化为C" class="headerlink" title="使用val将JavaScript转化为C++"></a>使用val将JavaScript转化为C++</h3><p>Embind提供C++类，emscripten::val,可以使用它们将JavaScript代码转化为C++代码。使用val可以从C++调用JavaScript对象，读取和写入他们的属性，或者强制它们使用C++值，比如bool,int或std::string.<br>线面这个例子展示了如何使用val从C++调用JavaScript的Web Audio API。<br>首先考虑如何在JavaScript中使用这个API:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Get web audio api context</span><br><span class="line">var AudioContext = window.AudioContext || window.webkitAudioContext;</span><br><span class="line"></span><br><span class="line">// Got an AudioContext: Create context and OscillatorNode</span><br><span class="line">var context = new AudioContext();</span><br><span class="line">var oscillator = context.createOscillator();</span><br><span class="line"></span><br><span class="line">// Configuring oscillator: set OscillatorNode type and frequency</span><br><span class="line">oscillator.type = &apos;tiangle&apos;;</span><br><span class="line">oscillator.frequency.value = 261.63; // value in hertz -middle C</span><br><span class="line"></span><br><span class="line">// Playing</span><br><span class="line">oscillator.connect(context.destination);</span><br><span class="line">oscillator.start();</span><br><span class="line"></span><br><span class="line">// All done!</span><br></pre></td></tr></table></figure></p><p>使用val,可以将这段代码转化为C++:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;emscripten/val.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace emscripten;</span><br><span class="line"></span><br><span class="line">ing main() &#123;</span><br><span class="line">    val AudioContext = val::global(&quot;AudioContext&quot;);</span><br><span class="line">    if (!AudioContext.as&lt;bool&gt;()) &#123;</span><br><span class="line">        printf(&quot;No global AudioContext, trying webkitAudioContext\n&quot;);</span><br><span class="line">        AudioContext = val::global(&quot;webkitAudioContext&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Got an AudioContext\n&quot;);</span><br><span class="line">    val context = AudioContext.new_();</span><br><span class="line">    val oscillator = context.call&lt;val&gt;(&quot;createOscillator&quot;);</span><br><span class="line">    val oscillator = context.call&lt;val&gt;(&quot;createOscillator&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Configuring oscillator\n&quot;);</span><br><span class="line">    oscillator.set(&quot;type&quot;, val(&quot;triangle&quot;));</span><br><span class="line">    oscillator[&quot;frequency&quot;].set(&quot;value&quot;, val(261.63)); //Middle C</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Playing\n&quot;);</span><br><span class="line">    oscillator.call&lt;void&gt;(&quot;connect&quot;, context[&quot;destination&quot;]);</span><br><span class="line">    oscillator.call&lt;void&gt;(&quot;start&quot;, 0);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;All done!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们首先使用global()来获取AudioContext全局对象符号，如果AudioContext不存在则获取webkitAudioContext。然后使用new_()来创建context,通过context我们可以创建oscillator,再次使用val来set它的属性，然后播放音调。<br>该示例可以在Linux/MacOSX终端上编译：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./emcc -O2 -Wall -Werror --bind -o oscillator.html oscillator.cpp</span><br></pre></td></tr></table></figure></p><h3 id="内建类型转换"><a href="#内建类型转换" class="headerlink" title="内建类型转换"></a>内建类型转换</h3><p>Embind提供了标准C++类型的转换：</p><table><thead><tr><th>C++类型</th><th>JavaScript类型</th></tr></thead><tbody><tr><td>void</td><td>undefined</td></tr><tr><td>bool</td><td>true or false</td></tr><tr><td>char</td><td>Number</td></tr><tr><td>signed char</td><td>Number</td></tr><tr><td>unsigned char</td><td>Number</td></tr><tr><td>short</td><td>Number</td></tr><tr><td>unsigned short</td><td>Number</td></tr><tr><td>int</td><td>Number</td></tr><tr><td>unsigned int</td><td>Number</td></tr><tr><td>long</td><td>Number</td></tr><tr><td>unsigned long</td><td>Number</td></tr><tr><td>float</td><td>Number</td></tr><tr><td>double</td><td>Number</td></tr><tr><td>std::string</td><td>ArrayBuffer, Uint8Array, Uint8ClampedArray, Int8Array, or String</td></tr><tr><td>std::wstring</td><td>String(UTF-16 code units)</td></tr><tr><td>emscritpen::val</td><td>anything</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> WebAssembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebAssembly </tag>
            
            <tag> Emscripten </tag>
            
            <tag> Embind </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell 多线程</title>
      <link href="/2018/10/21/shell_multi_thread/"/>
      <url>/2018/10/21/shell_multi_thread/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>如果完成一个linux任务，需要多条命令的话，我们通常将这些命令写成一个shell文件，shell脚本也就是一系列命令的集合。但是默认情况下这些命令时按顺序执行的，也就是说下一条命令会等待上一条命令执行完再执行。那么如何实现命令的并行执行呢？首先我们会想到将命令或任务放到后台去执行，这样确实可以实现命令的并行运行。但是如果命令太多，放入后台可能会影响系统其它程序的运行。怎么对命令的执行进行控制，达到我们所认识的”多线程的效果”，这就是下文所介绍的shell”多线程”的实现。<br><a id="more"></a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>下面我们通过对比一个实例来说明为什么使用”多线程”以及如何实现，假设并发检测1000台web服务器状态。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">start_time=`date +%s`   #定义任务开始运行的时间</span><br><span class="line">num_server=1000</span><br><span class="line">for num in `seq $num_server`    #seq命令如果后跟一个参数则将从1到这个数的所有整数都列出来，当然还可以跟两到三个参数</span><br><span class="line">do</span><br><span class="line">    sleep 1             #使用sleep 1来模仿检测一台服务器所花费的时间</span><br><span class="line">    echo &apos;success &apos;$i</span><br><span class="line">done</span><br><span class="line">stop_time=`date +%s`    #定义任务运行结束的时间</span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`s&quot; #总的任务所花费的时间</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success 1</span><br><span class="line">success 2</span><br><span class="line">success 3</span><br><span class="line">...</span><br><span class="line">success 998</span><br><span class="line">success 999</span><br><span class="line">success 1000</span><br><span class="line">TIME:1000s</span><br></pre></td></tr></table></figure></p><p>通过上面这个例子能够发现该脚本有一个很明显的弊端就是运行时间很长，这也正是为什么要使用”多线程”的原因。那么我们来看一下将任务放入后台运行情况<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">start_time=`date +%s`   #定义任务开始运行的时间</span><br><span class="line">num_server=1000</span><br><span class="line">for num in `seq $num_server`    #seq命令如果后跟一个参数则将从1到这个数的所有整数都列出来，当然还可以跟两到三个参数</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">    sleep 1             #使用sleep 1来模仿检测一台服务器所花费的时间</span><br><span class="line">    echo &apos;success &apos;$num</span><br><span class="line">&#125;&amp;                      #后面加一个&amp;符号，表示将任务放入后台运行，不会阻塞下一次for循环</span><br><span class="line">done</span><br><span class="line">wait                    #wait的命令时等待上面的命令运行完成后再向下执行，不然后面的计算时间有可能先输出出来</span><br><span class="line">stop_time=`date +%s`    #定义任务运行结束的时间</span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`s&quot; #总的任务所花费的时间</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success 1</span><br><span class="line">success 2</span><br><span class="line">success 3</span><br><span class="line">...</span><br><span class="line">success 998</span><br><span class="line">success 999</span><br><span class="line">success 1000</span><br><span class="line">TIME:11s</span><br></pre></td></tr></table></figure></p><p>从运行所花费的时间来看较上一个脚本要快很多，我的计算机是用了11s。计算机配置不同运行所需时间也不一样。按照理想状态，脚本运行所需要的时间应该不超过2s，而且在程序运行过程中，能够明显听到计算机的风扇发出的声音，可见是非常消耗资源的。这样给操作系统造成的压力就非常大，如何根据控制同时运行这么多的任务呢？<br>可以借鉴c++中使用多线程的方法，就是通过一个队列来控制，那么这个队列则可以使用系统中的管道来实现。虽然管道和队列有相同的特性，即按顺序存取，没有阻塞，但是和队列不同的是只能往管道文件中放入一段数据，如果没有及时取出就会阻塞。如何往管道里放多条数据呢，这就要用到文件描述符，代码如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">start_time=`date +%s`   #定义任务开始运行的时间</span><br><span class="line">[ -e /tmp/fd1 ] || mkfifo /tmp/fd1  #创建管道</span><br><span class="line">exec 3&lt;&gt;/tmp/fd1        #创建文件描述符并关以可读(&lt;)可写(&gt;)的方式关联管道文件,这里之所以选择3作为文件描述符，是因为习惯上，0为标准输入，1为标准输出，2为标准错误输出</span><br><span class="line">rm -rf /tmp/fd1         #关联后的文件描述符拥有管道文件的所有特性，这个时候可以删除管道文件</span><br><span class="line">for ((i=1;i&lt;=10;i++))</span><br><span class="line">do</span><br><span class="line">    echo &gt;&amp;3        #&amp;3表示引用文件描述符3,代表向管道里放入一把钥匙</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">num_server=1000</span><br><span class="line">for num in `seq $num_server`    #seq命令如果后跟一个参数则将从1到这个数的所有整数都列出来，当然还可以跟两到三个参数</span><br><span class="line">do</span><br><span class="line">read -u3            #代表从管道中取出一把钥匙</span><br><span class="line">&#123;</span><br><span class="line">    sleep 1             #使用sleep 1来模仿检测一台服务器所花费的时间</span><br><span class="line">    echo &apos;success &apos;$num</span><br><span class="line">    echo &gt;&amp;3            #代表命令执行后，将钥匙放回管道中</span><br><span class="line">&#125;&amp;                      #后面加一个&amp;符号，表示将任务放入后台运行，不会阻塞下一次for循环</span><br><span class="line">done</span><br><span class="line">wait                    #wait的命令时等待上面的命令运行完成后再向下执行，不然后面的计算时间有可能先输出出来</span><br><span class="line">stop_time=`date +%s`    #定义任务运行结束的时间</span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`s&quot; #总的任务所花费的时间</span><br><span class="line">exec 3&lt;&amp;-           #关闭文件描述符的读</span><br><span class="line">exec 3&gt;&amp;-           #关闭文件描述符的写</span><br></pre></td></tr></table></figure></p><p>代码运行结果：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">success 1</span><br><span class="line">success 2</span><br><span class="line">success 3</span><br><span class="line">...</span><br><span class="line">success 998</span><br><span class="line">success 999</span><br><span class="line">success 1000</span><br><span class="line">TIME:107s</span><br></pre></td></tr></table></figure></p><p>运行时间为107s,没有第二种方案运行的快，但比第一种方案快了很多，该方案实现了同一时间内最多只有10个线程的并发，既提高了效率，有实现了并发控制。</p>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客搭建笔记</title>
      <link href="/2018/10/13/hexo_and_markdown/"/>
      <url>/2018/10/13/hexo_and_markdown/</url>
      
        <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><hr><ul><li>本博客记录了我在搭建好我的博客网站后遇到的一些问题，以免日后遇到相同问题又要到处搜索，如果遇到和我相同问题的朋友也可以用作参考</li><li>在这里我将博客网站和博文的问题放在一篇文章中来统一介绍</li></ul><hr><a id="more"></a><h3 id="网站配置和主题配置"><a href="#网站配置和主题配置" class="headerlink" title="网站配置和主题配置"></a>网站配置和主题配置</h3><h4 id="博客网站配置"><a href="#博客网站配置" class="headerlink" title="博客网站配置"></a>博客网站配置</h4><hr><ul><li>找到hexo博客所在目录，打开配置文件_config.yml。下面是我所修改的一些内容,如果没有可以自己添加：</li><li>title：刘养硕的博客 //标题</li><li>subtitle: 记录工作和学习的点点滴滴  //副标题</li><li>description: 快乐生活，快乐学习 //描述</li><li>author: 刘养硕  //博主</li><li>language: zh_CN //中文语言，默认为英文，这个还要看你主题所支持的语言</li><li>还可以有keywords等选项，我的博客里面不显示就没有加</li><li>这里进行一下说明，在我打算修改博客为中文时（默认为英文），博客显示的语言不稳定，有时是英文，有时是中文，还有时会出现中文繁体，因此我没有在配置文件中修改语言选项（也就是language）。我修改的是主题文件夹下所支持的语言文件：进入到themes\aria\languages目录（aria是我所使用的主题），我对languages目录做了一下备份，然后将default.yml和zh_CN.yml以外的文件都删掉，最后修改defulet.yml中的内容为zh_CH.yml（默认为en.yml）</li></ul><hr><h4 id="修改博客的主题"><a href="#修改博客的主题" class="headerlink" title="修改博客的主题"></a>修改博客的主题</h4><hr><ul><li>在网上搜索hexo主题，进入到hexo官网主题网站，在下载之前可以先预览一下主题</li><li>找到自己喜欢的主题，进入到主题所在的github网站,复制主题的github网址。到博客的主题目录下使用git clone命令下载</li><li>下载好之后一定好阅读主题的README.md文件，里面会对该主题进行说明，至少会介绍主题配置，也就是修改博客的_config.yml文件中的theme。必要时还要下载支持该主题的一些插件，这个按照README.md中的说明操作即可</li><li>修改完博客的配置文件_config.yml之后，网站会应用该主题。如果要进一步确定网页的具体显示内容就要修改主题的配置文件，名字也是_config.yml（我的在themes\aria目录下）</li><li>修改菜单栏显示的内容，我的默认是只显示首页和归档，其余的是注释掉的。这里如果要显示其他菜单，如：分类，就将前面的注释符去掉。如果还不显示，就执行$ hexo new page “categories”命令,这时就会在source文件夹下生成一个categories文件夹。这时再启动服务就会看到网页上显示分类菜单，其他的也一样</li></ul><hr><h4 id="修改博客的头像"><a href="#修改博客的头像" class="headerlink" title="修改博客的头像"></a>修改博客的头像</h4><hr><ul><li>首先找到一张自己喜欢的图片（静态动态都可以，最好是正方形的），然后将图片放到themes\aria\source\images文件夹</li><li>同样是在主题的配置文件_config.yml中，找到avatar,如果没有就手动添加，将原来的修改为avatar: images/xiaohei2.gif。xiaohei2.gif是我的一张动态图片的名字，同样也可以修改logo的图片</li></ul><hr><h3 id="修改博文"><a href="#修改博文" class="headerlink" title="修改博文"></a>修改博文</h3><hr><ul><li>给文章添加标题使用title关键字，如title： 博客笔记</li><li>给文章添加标签使用tags，格式同上</li><li>给文章添加分类使用categories，格式同上</li><li>如果添加多个标签或分类如下图所示</li><li><img src="https://github.com/liuyangshuo/liuyangshuo.github.io/raw/master/img/tags.jpg" alt="添加多个标签"></li><li><p>在文章中插入图片，我用的是有道云笔记写markdown的。软件支持直接拖入图片，就是需要会员，所以我手动插入的。我是现将图片放到该博客的github上，首先在source目录下新建一个img文件夹，将图片放到img文件夹下，然后使用hexo d将该图片推送到github上（我这里对于本博客所对应github没有使用git push权限）。进入到你的github网站，找到该图片，然后将该图片的网址复制出来，在你想放图片位置使用:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片说明](图片所在github网址)</span><br></pre></td></tr></table></figure></li><li><p>将网址粘贴到小括号内。这时还不能显示图片，在刚才粘贴网址中找到blob,并将blob改为raw,发布文章就可以看到了</p></li><li>说明一下，在博客目录下有一个和github目录对应的public文件夹，在每次执行hexo cleand命令时该文件夹都会被清空。在执行hexo g时优惠重新生成该文件夹，然后使用hexo d将public文件夹中的额内容推送到github上。我刚开始不了解，就将图片放到public目录下的images文件夹，结果每次发布就会丢失图片。正确的做法是放到source的一个文件夹或者是主题下的images文件夹，目的是在生成public文件夹时能够找到该图片。我之所以不放到主题下的images文件夹，是因为我不想文章和主题相关联，这样之后在更换主题时还要再修改图片位置</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++知识总结之abs函数</title>
      <link href="/2018/10/10/C++_abs/"/>
      <url>/2018/10/10/C++_abs/</url>
      
        <content type="html"><![CDATA[<h3 id="abs函数"><a href="#abs函数" class="headerlink" title="abs函数"></a>abs函数</h3><hr><ul><li>abs函数存在于不止一个库中，使用哪个库中的abs函数就可以包含哪个头文件</li><li>其中在c标准库stdlib.h中abs函数只接受整型或长整型，在c98标准中参数类型可以是int或long int类型；c11标准中还可以是long long int类型</li><li>在数学函数库cmath/math.h中，在c++98标准中abs可接受的参数类型为double/float/long double；在c++11中还可以接受各种整型参数。abs还可以写成fabs，这两个用法是一样的，labs则只接受long int类型的参数。在c++11中头文件可以写cmath,c++98只能写math.h</li><li>abs函数的返回值和参数类型保持一致</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> abs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git 学习</title>
      <link href="/2018/10/06/git_command/"/>
      <url>/2018/10/06/git_command/</url>
      
        <content type="html"><![CDATA[<h3 id="版本库简介"><a href="#版本库简介" class="headerlink" title="版本库简介"></a>版本库简介</h3><hr><ul><li>cvs和svn都是集中式版本控制系统，git是分布式版本控制系统</li><li>集中式一旦中央服务器坏掉，使用该版本库的所有员工都无法工作</li><li>而分布式每个人的电脑都相当于一个完整的版本库，无需联网一样工作，分布式较集中式的安全性要高很多</li><li>本文介绍git使用的一些常用的命令</li></ul><hr><a id="more"></a><p><img src="https://github.com/liuyangshuo/liuyangshuo.github.io/raw/master/img/git.jpg" alt="git数据传输指令"></p><h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"lys"</span></span><br><span class="line">$ git config --global user.email <span class="string">"liu_yangshuo@163.com"</span></span><br></pre></td></tr></table></figure><h3 id="git获取版本库"><a href="#git获取版本库" class="headerlink" title="git获取版本库"></a>git获取版本库</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> http://xxxxxx</span><br></pre></td></tr></table></figure><h3 id="git初始化一个新仓库"><a href="#git初始化一个新仓库" class="headerlink" title="git初始化一个新仓库"></a>git初始化一个新仓库</h3><p>新建一个文件夹，然后在文件夹下执行：<br><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></p><p>执行完命令就会在该文件夹下生成.git文件夹</p><h3 id="git代码提交流程"><a href="#git代码提交流程" class="headerlink" title="git代码提交流程"></a>git代码提交流程</h3><hr><ol><li>新建或修改文件</li><li>使用 git add 命令将文件添加到缓存区</li><li>使用 git commit 将修改文件提交到本地代码库</li><li>使用 git push 将本地文件同步到远程代码库</li></ol><hr><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git status  //使用该命令可以判断git代码提交流程执行到哪一步，该命令显示当前的状态信息</span><br><span class="line">$ git diff    //该命令会显示当前已修改但是还没加入缓存区的内容</span><br><span class="line">$ git diff --cached   //该命令显示使用git add加入到缓存区中的文件内容</span><br><span class="line">$ git commit -m <span class="string">"git log"</span>    //将加入到缓存区中的内容提交到本地版本库，</span><br><span class="line">$ git commit -a -m <span class="string">"git log"</span>  //如果不是用git add那么这个命令只会将修改的文件提交到版本库，不会提交新建文件</span><br><span class="line">$ git branch  //查看所有分支，以及当前所在分支</span><br><span class="line">$ git branch branch_01_01 //新建一个分支</span><br><span class="line">$ git checkout master //切换分支</span><br><span class="line">$ git merge -m <span class="string">'merge branch_01_01 branch'</span> branch_01_01    //将branch_01_01分支合并到当前分支</span><br><span class="line">$ git branch -d branch_01_01  //删除分支branch_01_01,该命令只能删除已经合并的分支，如果强制删除某个分支使用-D参数</span><br><span class="line">$ git reset --head HEAD^  //撤销合并的内容</span><br><span class="line">$ git <span class="built_in">log</span> //查看所有日志</span><br><span class="line">$ git <span class="built_in">log</span> v1.1... main.cpp /<span class="built_in">source</span> //该命令显示从v1.1开发<span class="built_in">source</span>目录下所有main.cpp文件的修改</span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span>  //该命令显示日志更详细的内容</span><br><span class="line">$ git <span class="built_in">log</span> --pretty=[online/medium/short/full/fuller/email/raw] //格式化日志输出</span><br><span class="line">$ git <span class="built_in">log</span> --graph --pretty=online   //--graph选项用来可视化日志</span><br><span class="line">$ git diff master <span class="built_in">test</span>  //比较分支<span class="built_in">test</span>和主线master的区别</span><br><span class="line">$ git diff <span class="built_in">test</span> //比较<span class="built_in">test</span>分支和当前分支的差别</span><br><span class="line">$ git diff <span class="built_in">test</span> file1   //比较分支<span class="built_in">test</span>中file1和当前分支file1的差别</span><br><span class="line">$ git diff <span class="built_in">test</span> --<span class="built_in">stat</span>  //统计都有哪些文件，哪些行有差别</span><br><span class="line">$ git tag tag-1 b1a2f004 //打一个名为tag-1的标签，b1a2f004为commit名称的前8位</span><br><span class="line">$ git tag -a tag-2 b1a2f004 -m <span class="string">"tag 2"</span>  //创建一个标签对象，并添加注释</span><br><span class="line">$ git checkout 3c648e54b41e022e20a42fdbb23eed922e08c480 //下载特定历史版本的代码</span><br><span class="line">$ git config --list //查看所有配置</span><br><span class="line">$ git config --global --replace-all user.name <span class="string">"xxxxx"</span> // 如果出现user.name has multiple value 警告时修改用户名或邮箱的值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/14/hello-world/"/>
      <url>/2018/06/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
