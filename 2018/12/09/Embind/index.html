<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    <meta name="keywords" content="Life, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="刘养硕的博客" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>Emscripten Embind | 刘养硕的博客 - 记录工作和学习的点点滴滴</title>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="default"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">刘养硕的博客</a></h1>
        <h2 class="subtitle">记录工作和学习的点点滴滴</h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/">首页</a></li>
        
        <li role="menuitem"><a href="/archives/">归档</a></li>
        
        <li role="menuitem"><a href="/categories/">分类</a></li>
        
        <li role="menuitem"><a href="/tags/">标签</a></li>
        
        <li role="menuitem"><a href="/about/">关于</a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://liuyangshuo.com/2018/12/09/Embind/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="刘养硕">
       <meta itemprop="description" content="快乐生活，快乐学习">
       <meta itemprop="image" content="/images/xiaohei2.gif">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="刘养硕的博客">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">Emscripten Embind</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-12-09T10:30:00+08:00">2018-12-09 10:30:00</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WebAssembly/" itemprop="url" rel="index"><span itemprop="name">WebAssembly</span></a></span>
        </span>
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <p>Embind用于将C++函数和类绑定到javascript,这样编译的代码就可以通过javascript来调用<br>本文介绍如何使用EMSCRIPTEN_BINDINGS()块来为函数、类、值类型、指针（包括原始指针和智能指针）、枚举和常量创建绑定，以及如何为可以在javascript中重写的抽象类创建绑定。还简要解释了如何管理传递给javascript的C++对象句柄的内存</p>
<hr>
<a id="more"></a>
<h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p>下面以一个简单的例子开始</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//quick_example.cpp</span><br><span class="line">#include &lt;emscripten/bind.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace emscripten;</span><br><span class="line"></span><br><span class="line">float lerp(float a, float b, float t) &#123;</span><br><span class="line">    return (1 - t) * a + t * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(my_module) &#123;</span><br><span class="line">    function(&quot;lerp&quot;, &amp;lerp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面对以上代码进行编译，编译需要加–bind参数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emcc --bind -o quick_example.js quick_example.cpp</span><br></pre></td></tr></table></figure></p>
<p>编译之后就可以在javascript代码中调用上边的注册函数</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Module = &#123;</span><br><span class="line">    onRuntimeInitialized: function() &#123;</span><br><span class="line">        console.log(&apos;lerp result: &apos; + Module.lerp(1, 2, 0.5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;quick_example.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="类和内存管理"><a href="#类和内存管理" class="headerlink" title="类和内存管理"></a>类和内存管理</h3><p>向javascript公开类需要一个更复杂的绑定语句：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    MyClass(int x, std::string y): x(x), y(y) &#123;&#125;</span><br><span class="line">    void incrementX() &#123;</span><br><span class="line">        ++x;</span><br><span class="line">    &#125;</span><br><span class="line">    int getX() const &#123; return x;&#125;</span><br><span class="line">    void setX(int x_) &#123; x = x_; &#125;</span><br><span class="line">    static std::string getStringFromInstance(const MyClass&amp; instance) &#123;</span><br><span class="line">        return instance.y;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">    std::stirng y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//Binding code</span><br><span class="line">EMSCRIPTEN_BINDINGS(my_class_example) &#123;</span><br><span class="line">    class_&lt;MyClass&gt;(&quot;MyClass&quot;)</span><br><span class="line">    .constructor&lt;int, std::string&gt;() //构造函数</span><br><span class="line">    .function(&quot;incrementX&quot;, &amp;MyClass::incrementX) //非静态函数</span><br><span class="line">    .property(&quot;x&quot;, &amp;MyClass::getX, &amp;MyClass:setX)</span><br><span class="line">    .class_function(&quot;getStringFromInstance&quot;, &amp;MyClass:getStringFromInstance) //静态函数</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在javascript中使用：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var instance = new Module.MyClass(10, &quot;hello&quot;);</span><br><span class="line">instance.incrementX();</span><br><span class="line">instance.x; // 11</span><br><span class="line">instance.x = 20 // 20</span><br><span class="line">Module.MyClass.getStringFromInstance(instance); // &quot;hello&quot;</span><br><span class="line">instance.delete();</span><br></pre></td></tr></table></figure>
<p>由于Emscripten无法自动调用C++对象的析构函数，所以javascript代码必须显示删除他接收到的任何C++对象句柄，否则Emscripten堆将无限期地增长</p>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>基本类型的手动内存管理非常麻烦，因此Embind提供对值类型的支持。Value arrays转换为javascript数组和value objects转换为javascript对象</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct Point2f &#123;</span><br><span class="line">    float x;</span><br><span class="line">    float y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct PersonRecord &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PersonRecord findPersonAtLocation(Point2f);</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(my_value_example) &#123;</span><br><span class="line">    value_array&lt;Point2f&gt;(&quot;Point2f&quot;)</span><br><span class="line">        .element(&amp;Point2f::x)</span><br><span class="line">        .element(&amp;Point2f::y)</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">    value_object&lt;PersonRecord&gt;(&quot;PersonRecord&quot;)</span><br><span class="line">        .field(&quot;name&quot;, &amp;PersonRecord::name)</span><br><span class="line">        .field(&quot;age&quot;, &amp;PersonRecord::age)</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">    function(&quot;findPersonAtLocation&quot;, &amp;findPersonAtLocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式javascript就无需考虑对象的生命周期</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person = Module.findPersonAtLocation([10.2, 156.5]);</span><br><span class="line">console.log(&apos;Found someone! Their name is &apos; + person.name + &apos;and they are&apos; + person.age + &apos; years old&apos;);</span><br></pre></td></tr></table></figure>
<h3 id="高级类概念"><a href="#高级类概念" class="headerlink" title="高级类概念"></a>高级类概念</h3><h4 id="原始指针"><a href="#原始指针" class="headerlink" title="原始指针"></a>原始指针</h4><p>因为原始指针的语义不明确，embind需要将使用allow_raw_pointers标记：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;&#125;;</span><br><span class="line">C* passThrough(C* ptr) &#123; return ptr; &#125;</span><br><span class="line">EMSCRIPTEN_BINDINGS(raw_pointers) &#123;</span><br><span class="line">    class&gt;&lt;C&gt;(&quot;C&quot;);</span><br><span class="line">    function(&quot;passThrough&quot;, &amp;passThrough, allow_raw_pointers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="外部构造函数"><a href="#外部构造函数" class="headerlink" title="外部构造函数"></a>外部构造函数</h4><p>这里有两种方法来指定类的构造函数<br>一种是零参数模板形式，使用模板中指定的参数调用自然构造函数：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    MyClass(int, float);</span><br><span class="line">    void someFunction();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(external_constructors) &#123;</span><br><span class="line">    class_&lt;MyClass&gt;(&quot;MyClass&quot;)</span><br><span class="line">        .constructor&lt;int, float&gt;()</span><br><span class="line">        .function(&quot;someFunction&quot;, &amp;MyClass::someFunction)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种形式是接受函数指针参数，并用于使用工厂函数构造自身的类：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    virtual void someFunction() = 0；</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass* makeMyClass(int, float); //Factory function</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(external_constructors) &#123;</span><br><span class="line">    class_&lt;MyClass&gt;(&quot;MyClass&quot;)</span><br><span class="line">        .constructor(&amp;makeMyClass, allow_raw_pointers())</span><br><span class="line">        .function(&quot;someFunction&quot;, &amp;MyClass::someFunction)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面两种形式作为接口在JavaScript中使用时是相同的：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var instance = new MyClass(10, 15.5);</span><br><span class="line">// instance is backed by a raw pointer to a MyClass in the Emscripten heap</span><br></pre></td></tr></table></figure>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>如果要使用智能指针来管理对象的生存周期，Embind必须指出智能指针的类型。<br>例如，考虑通过一个指向类C的智能指针std::shared_ptr<c>的生存周期，最好的方式是使用smart_ptr_constructor()来注册智能指针类型：</c></p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(better_smart_pointers) &#123;</span><br><span class="line">    class_&lt;C&gt;(&quot;C&quot;)</span><br><span class="line">        .smart_ptr_constructor(&quot;C&quot;, &amp;std::make_shared&lt;C&gt;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这个类型的一个对象被构造（如，new Module.C() ),就会返回一个智能指针std::shared_ptr<c>.<br>另一只形式是在EMSCRIPTEN_BINDINGS()中使用smart_ptr().</c></p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(smart_pointers) &#123;</span><br><span class="line">    class_&lt;C&gt;(&quot;C&quot;)</span><br><span class="line">        .constructor&lt;&gt;()</span><br><span class="line">        .smart_ptr&lt;std::shared_ptr&lt;C&gt;&gt;(&quot;C&quot;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用该定义可以返回一个std::shared_ptr<c>。或者使用std::shared_ptr<c>作为参数，但是使用new Module.C()将会返回一个原始指针。</c></c></p>
<h5 id="唯一智能指针"><a href="#唯一智能指针" class="headerlink" title="唯一智能指针"></a>唯一智能指针</h5><p>同共享指针一样不过返回类型为std::unique_ptr。</p>
<h5 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h5><p>关于自定义智能指针模板，必须使用专门的smart_ptr_trait模板。</p>
<h4 id="JavaScript原型上的非成员函数"><a href="#JavaScript原型上的非成员函数" class="headerlink" title="JavaScript原型上的非成员函数"></a>JavaScript原型上的非成员函数</h4><p>JavaScript原型上的方法可以是非成员函数，主要实例句柄可以转换为非成员函数的第一个参数。典型的例子是当向JavaScript公开的函数与C++方法的行为不完全匹配时。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Array10 &#123;</span><br><span class="line">    int&amp; get(size_t index) &#123;</span><br><span class="line">        return data[index];</span><br><span class="line">    &#125;</span><br><span class="line">    int data[10];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">val Array10_get(Array10&amp; arr, size_t index) &#123;</span><br><span class="line">    if (index &lt; 10) &#123;</span><br><span class="line">        return val(arr.get(index));</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">            return val::undefined();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(non_member_functions) &#123;</span><br><span class="line">    class_&lt;Array10&gt;(&quot;Array10&quot;)</span><br><span class="line">        .function(&quot;get&quot;, &amp;Array10_get)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在JavaScript中派生C-类"><a href="#在JavaScript中派生C-类" class="headerlink" title="在JavaScript中派生C++类"></a>在JavaScript中派生C++类</h4><p>如果C++类中有虚拟或抽象成员函数，则可以在JavaScript中重写他们。因为JavaScript没有C++虚函数表的信息，Embind需要一点胶水代码将C++虚函数调用转换为JavaScript调用。</p>
<h5 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h5><p>通过一个例子来说明，该方法必须通过JavaScript实现。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Interface &#123;</span><br><span class="line">    virtual void invoke(const std::string&amp; str) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct InterfaceWrapper : public wrapper&lt;Interface&gt; &#123;</span><br><span class="line">    EMSCRIPTEN_WRAPPER(InterfaceWrapper);</span><br><span class="line">    void invoke(const std::string&amp; str) &#123;</span><br><span class="line">        return call&lt;void&gt;(&quot;invoke&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(interface) &#123;</span><br><span class="line">    class_&lt;Interface&gt;(&quot;Interface&quot;)</span><br><span class="line">        .function(&quot;invoke&quot;, &amp;Interface::invoke, pure_virtual())</span><br><span class="line">        .allow_subclass&lt;InterfaceWrapper&gt;(&quot;InterfaceWrapper&quot;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>allow_subclass()向接口绑定添加两个特殊方法：extend和implement。extend循序JavaScript在样式中子类。当有JavaScript对象时使用implement。并且希望使用它来实现C++接口。</p>
<h5 id="extend例子"><a href="#extend例子" class="headerlink" title="extend例子"></a>extend例子</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var DerivedClass = Module.Interface.extend(&quot;Interface&quot;, &#123;</span><br><span class="line">    // __construct and __destruct are optional. They are included</span><br><span class="line">    // in this example for illustration purposes.</span><br><span class="line">    // If you override __construct or __destruct, don&apos;t forget to </span><br><span class="line">    // call the parent implementation!</span><br><span class="line">    __construct : function() &#123;</span><br><span class="line">        this.__parent.__construct.call(this);</span><br><span class="line">    &#125;,</span><br><span class="line">    __destruct : function() &#123;</span><br><span class="line">        this.__parent.__destruct.call(this);</span><br><span class="line">    &#125;,</span><br><span class="line">    invoke : function() &#123;</span><br><span class="line">        // your code goes here</span><br><span class="line">    &#125;, </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var instance = new DerivedClass;</span><br></pre></td></tr></table></figure>
<h5 id="implement例子"><a href="#implement例子" class="headerlink" title="implement例子"></a>implement例子</h5><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x &#123;</span><br><span class="line">    invoke : function(str) &#123;</span><br><span class="line">        console.log(&apos;invoking with: &apos; + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var interfaceObject = Module.Interface.implement(x);</span><br></pre></td></tr></table></figure>
<p>现在interfaceObject可以传递给任何接受Interface指针或引用。</p>
<h5 id="非抽象虚拟方法"><a href="#非抽象虚拟方法" class="headerlink" title="非抽象虚拟方法"></a>非抽象虚拟方法</h5><p>如果C++类具有非纯虚函数，则可以重写它，但不必重写。这需要一个稍微不同的包装器实现:</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct Base &#123;</span><br><span class="line">    virtual void invoke(const std::string&amp; str) &#123;</span><br><span class="line">        //default implementation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct BaseWrapper : public Wrapper&lt;Base&gt; &#123;</span><br><span class="line">    EMSCRIPTEN_WRAPPER(BaseWrapper);</span><br><span class="line">    void invoke(const std::string&amp; str) &#123;</span><br><span class="line">        return call&lt;void&gt;(&quot;invoke&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(interface) &#123;</span><br><span class="line">    class_&lt;Base&gt;(&quot;Base&quot;)</span><br><span class="line">        .allow_subclass&lt;BaseWrapper&gt;(&quot;BaseWrapper&quot;)</span><br><span class="line">        .function(&quot;invoke&quot;, optional_override([](Base&amp; self, const std::)stirng&amp; str)&#123;</span><br><span class="line">            return self.Base::invoke(str);</span><br><span class="line">        &#125;))</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用JavaScript对象来实现Base时，invoke是可选择的。为了避免wrapper和JavaScript质检出现无线循环必须为invoke使用特殊的lambda绑定。</p>
<h5 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h5><p>基类绑定的定义如下：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(base_example) &#123;</span><br><span class="line">    class_&lt;BaseClass&gt;(&quot;BaseClass&quot;);</span><br><span class="line">    class_&lt;DerivedClass, base&lt;BaseClass&gt;&gt;(&quot;DerivedClass&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义的任何BaseClass的成员函数可以访问DerivedClass的实例。此外，任何接受BaseClass实例的函数可以给一个DerivedClass的实例。</p>
<h5 id="自动向下传递"><a href="#自动向下传递" class="headerlink" title="自动向下传递"></a>自动向下传递</h5><p>如果C++类是多态的（也就是说，它有一个虚方法），那么Embind支持函数返回值的自动下传。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123; virtual ~ Base() &#125;; //the virtual makes Base and Derived Polymorphic</span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line">Base* getDerivedInstance() &#123;</span><br><span class="line">    return new Derived;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(automatic_downcasting) &#123;</span><br><span class="line">    class_&lt;Base&gt;(&quot;Base&quot;);</span><br><span class="line">    class_&lt;Derived， base&lt;Base&gt;&gt;(&quot;Derived&quot;);</span><br><span class="line">    function(&quot;getDerivedInstance&quot;, &amp;getDerivedInstance, allow_raw_pointers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JavaScript中调用Module.getDerivedInstance,返回Derived实例句柄，其中所有Derived方法是可用的。</p>
<h3 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h3><p>构造函数和普通函数可以在参数上重载，但是Enbind不支持基于类型的重载。指定重载是，使用select_overload()函数来选择适当的签名。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct HasOverloadedMethods &#123;</span><br><span class="line">    void foo();</span><br><span class="line">    void foo(int i);</span><br><span class="line">    void foo(float f) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(overloads) &#123;</span><br><span class="line">    class_&lt;HasOverloadedMethods&gt;(&quot;HasOverloadedMethods&quot;)</span><br><span class="line">        .function(&quot;foo&quot;, select_overload&lt;void()&gt;(&amp;HasOverloadedMethods::foo))</span><br><span class="line">        .function(&quot;foo_int&quot;, select_overload&lt;void(int)&gt;(&amp;HasOverloadedMethods::foo))</span><br><span class="line">        .function(&quot;foo_float&quot;, select_overload&lt;void(float)&gt;(&amp;HasOverloadMethods::foo))</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h3><p>直接通过例子来看一下enum是如何使用：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">enum OldStyle &#123;</span><br><span class="line">    OLD_STYLE_ONE,</span><br><span class="line">    OLD_STYLE_TWO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum class NewStyle &#123;</span><br><span class="line">    ONE,</span><br><span class="line">    TWO</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(my_enum_example) &#123;</span><br><span class="line">    enum_&lt;OldStyle&gt;(&quot;OldStyle&quot;)</span><br><span class="line">        .value(&quot;ONE&quot;, OLD_STYLE_ONE)</span><br><span class="line">        .value(&quot;TWO&quot;, OLD_STYLE_TWO)</span><br><span class="line">        ;</span><br><span class="line">    enum_&lt;NewStyle&gt;(&quot;NewStyle&quot;)</span><br><span class="line">        .value(&quot;ONE&quot;, NewStyle::ONE)</span><br><span class="line">        .value(&quot;TWO&quot;, NewStyle::TWO)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个例子中，JavaScript都将枚举值作为类型的属性访问：</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Module.OldStyle.ONE;</span><br><span class="line">Module.NewStyle.TWO;</span><br></pre></td></tr></table></figure>
<h3 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h3><p>JavaScript使用C++常数</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EMSCRIPTEN_BINDINGS(my_constant_example) &#123;</span><br><span class="line">    constant(&quot;DOME_CONSTANT&quot;, SOME_CONSTANT);</span><br><span class="line">&#125;</span><br><span class="line">SOME_CONSTANT可以有任何已知的类型</span><br></pre></td></tr></table></figure>
<h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p>在某些情况下，将原始二进制直接公开给JavaScript代码作为类型化数组是很有价值的，这样就可以在不进行复制的情况下使用它。例如，这对于直接从堆上传大型WebGL纹理非常有用。<br>内存视图应该被视为原始指针；运行时不对生存期和有效性进行管理，而且如果修改或释放底层对象，则很容易损坏数据。<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;emscripten/bind.h&gt;</span><br><span class="line">#include &lt;emscripten/val.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace emscripten;</span><br><span class="line"></span><br><span class="line">unsigned char *byteBuffer = /* ... */;</span><br><span class="line">size_t bufferLength = /* ... */;</span><br><span class="line"></span><br><span class="line">val getBytes() &#123;</span><br><span class="line">    return val(typed_memory_view(bufferLength, byteBuffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EMSCRIPTEN_BINDINGS(memory_view_example) &#123;</span><br><span class="line">    function(&quot;getBytes&quot;, &amp;getBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的JavaScript代码将在Emscripten堆中接受一个类型化数组视图：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myUint8Array = Module.getBytes()</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;POST&apos;, /* ... */);</span><br><span class="line">xhr.send(myUint8Array);</span><br></pre></td></tr></table></figure></p>
<p>类型化数组视图将具有适当的匹配类型，例如unsigned char 数组或指针。</p>
<h3 id="使用val将JavaScript转化为C"><a href="#使用val将JavaScript转化为C" class="headerlink" title="使用val将JavaScript转化为C++"></a>使用val将JavaScript转化为C++</h3><p>Embind提供C++类，emscripten::val,可以使用它们将JavaScript代码转化为C++代码。使用val可以从C++调用JavaScript对象，读取和写入他们的属性，或者强制它们使用C++值，比如bool,int或std::string.<br>线面这个例子展示了如何使用val从C++调用JavaScript的Web Audio API。<br>首先考虑如何在JavaScript中使用这个API:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Get web audio api context</span><br><span class="line">var AudioContext = window.AudioContext || window.webkitAudioContext;</span><br><span class="line"></span><br><span class="line">// Got an AudioContext: Create context and OscillatorNode</span><br><span class="line">var context = new AudioContext();</span><br><span class="line">var oscillator = context.createOscillator();</span><br><span class="line"></span><br><span class="line">// Configuring oscillator: set OscillatorNode type and frequency</span><br><span class="line">oscillator.type = &apos;tiangle&apos;;</span><br><span class="line">oscillator.frequency.value = 261.63; // value in hertz -middle C</span><br><span class="line"></span><br><span class="line">// Playing</span><br><span class="line">oscillator.connect(context.destination);</span><br><span class="line">oscillator.start();</span><br><span class="line"></span><br><span class="line">// All done!</span><br></pre></td></tr></table></figure></p>
<p>使用val,可以将这段代码转化为C++:<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;emscripten/val.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace emscripten;</span><br><span class="line"></span><br><span class="line">ing main() &#123;</span><br><span class="line">    val AudioContext = val::global(&quot;AudioContext&quot;);</span><br><span class="line">    if (!AudioContext.as&lt;bool&gt;()) &#123;</span><br><span class="line">        printf(&quot;No global AudioContext, trying webkitAudioContext\n&quot;);</span><br><span class="line">        AudioContext = val::global(&quot;webkitAudioContext&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Got an AudioContext\n&quot;);</span><br><span class="line">    val context = AudioContext.new_();</span><br><span class="line">    val oscillator = context.call&lt;val&gt;(&quot;createOscillator&quot;);</span><br><span class="line">    val oscillator = context.call&lt;val&gt;(&quot;createOscillator&quot;);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Configuring oscillator\n&quot;);</span><br><span class="line">    oscillator.set(&quot;type&quot;, val(&quot;triangle&quot;));</span><br><span class="line">    oscillator[&quot;frequency&quot;].set(&quot;value&quot;, val(261.63)); //Middle C</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Playing\n&quot;);</span><br><span class="line">    oscillator.call&lt;void&gt;(&quot;connect&quot;, context[&quot;destination&quot;]);</span><br><span class="line">    oscillator.call&lt;void&gt;(&quot;start&quot;, 0);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;All done!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们首先使用global()来获取AudioContext全局对象符号，如果AudioContext不存在则获取webkitAudioContext。然后使用new_()来创建context,通过context我们可以创建oscillator,再次使用val来set它的属性，然后播放音调。<br>该示例可以在Linux/MacOSX终端上编译：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./emcc -O2 -Wall -Werror --bind -o oscillator.html oscillator.cpp</span><br></pre></td></tr></table></figure></p>
<h3 id="内建类型转换"><a href="#内建类型转换" class="headerlink" title="内建类型转换"></a>内建类型转换</h3><p>Embind提供了标准C++类型的转换：</p>
<table>
<thead>
<tr>
<th>C++类型</th>
<th>JavaScript类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>void</td>
<td>undefined</td>
</tr>
<tr>
<td>bool</td>
<td>true or false</td>
</tr>
<tr>
<td>char</td>
<td>Number</td>
</tr>
<tr>
<td>signed char</td>
<td>Number</td>
</tr>
<tr>
<td>unsigned char</td>
<td>Number</td>
</tr>
<tr>
<td>short</td>
<td>Number</td>
</tr>
<tr>
<td>unsigned short</td>
<td>Number</td>
</tr>
<tr>
<td>int</td>
<td>Number</td>
</tr>
<tr>
<td>unsigned int</td>
<td>Number</td>
</tr>
<tr>
<td>long</td>
<td>Number</td>
</tr>
<tr>
<td>unsigned long</td>
<td>Number</td>
</tr>
<tr>
<td>float</td>
<td>Number</td>
</tr>
<tr>
<td>double</td>
<td>Number</td>
</tr>
<tr>
<td>std::string</td>
<td>ArrayBuffer, Uint8Array, Uint8ClampedArray, Int8Array, or String</td>
</tr>
<tr>
<td>std::wstring</td>
<td>String(UTF-16 code units)</td>
</tr>
<tr>
<td>emscritpen::val</td>
<td>anything</td>
</tr>
</tbody>
</table>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/WebAssembly/" rel="tag"><i class="fas fa-tags"></i>WebAssembly</a>
        
        <a class="post-tag button" href="/tags/Emscripten/" rel="tag"><i class="fas fa-tags"></i>Emscripten</a>
        
        <a class="post-tag button" href="/tags/Embind/" rel="tag"><i class="fas fa-tags"></i>Embind</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2018/10/21/shell_multi_thread/" rel="next" title="shell 多线程"><i class="fas fa-angle-left"></i><span class="nav-title">shell 多线程</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
      <a href="/2018/12/12/IndexedDB/" rel="prev" title="Emscripten IndexedDB"><span class="nav-title">Emscripten IndexedDB</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/xiaohei2.gif" alt="刘养硕">
  
  <h1 class="author-name">刘养硕</h1>
  <h2 class="author-description">快乐生活，快乐学习</h2>
  <div class="site-count">
    
    <div class="archives-count">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">7</a></div>
    </div>
    
    
    
    <span class="site-count-divider divider">|</span>
    
    <div class="categories-count">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">5</a></div>
    </div>
    
    
    
    <span class="site-count-divider divider">|</span>
    
    <div class="tags-count">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">14</a></div>
    </div>
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#普通函数"><span class="toc-text">普通函数</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#类和内存管理"><span class="toc-text">类和内存管理</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#值类型"><span class="toc-text">值类型</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#高级类概念"><span class="toc-text">高级类概念</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#原始指针"><span class="toc-text">原始指针</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#外部构造函数"><span class="toc-text">外部构造函数</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#智能指针"><span class="toc-text">智能指针</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#唯一智能指针"><span class="toc-text">唯一智能指针</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#自定义智能指针"><span class="toc-text">自定义智能指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#JavaScript原型上的非成员函数"><span class="toc-text">JavaScript原型上的非成员函数</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#在JavaScript中派生C-类"><span class="toc-text">在JavaScript中派生C++类</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#抽象方法"><span class="toc-text">抽象方法</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#extend例子"><span class="toc-text">extend例子</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#implement例子"><span class="toc-text">implement例子</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#非抽象虚拟方法"><span class="toc-text">非抽象虚拟方法</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#基类"><span class="toc-text">基类</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#自动向下传递"><span class="toc-text">自动向下传递</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#重载函数"><span class="toc-text">重载函数</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Enums"><span class="toc-text">Enums</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#常数"><span class="toc-text">常数</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#内存视图"><span class="toc-text">内存视图</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#使用val将JavaScript转化为C"><span class="toc-text">使用val将JavaScript转化为C++</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#内建类型转换"><span class="toc-text">内建类型转换</span></a></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接</p></div>
      <ul>
        
        <li><i class="fas fa-envelope"></i><a href="mailto:youremail@youremailhost" target="_blank">E-Mail</a></li>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/" target="_blank">GitHub</a></li>
        
        <li><i class="fab fa-weibo"></i><a href="https://weibo.com/" target="_blank">Weibo</a></li>
        
      </ul>
    </div>
    
    
    <hr>
    <div class="blogroll sidebar-item">
      <div><i class="fas fa-link"></i>友情链接</div>
      <ul>
        
        <li><i class="fas fa-link"></i><a href="https://github.com/" target="_blank">GitHub</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://developer.mozilla.org/" target="_blank">MDN</a></li>
        
        <li><i class="fas fa-link"></i><a href="https://mozilla.github.io/nunjucks/" target="_blank">Nunjucks</a></li>
        
      </ul>
    </div>
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">刘养硕</span><span class="year"><i class="far fa-copyright"></i>2018</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
